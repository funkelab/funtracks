from __future__ import annotations

from .feature import Feature, FeatureType


class FeatureSet:
    """A class to keep track of and manipulate the Features available on a graph.

    Use this class to:

    - list all available (node/edge) features
    - add node/edge features so that they can be discovered by other parts of the
        application
    - conveniently access the features that have a specific meaning for the application
        (e.g. time, position)
    """

    def __init__(
        self,
        time_feature: Feature,
        pos_feature: Feature | list[Feature],
        extra_features: list[Feature] | None = None,
    ):
        """
        Args:
            time_feature (Feature): The feature to use as the time. Usually Time(),
                but can be given a different key.
            pos_feature (Feature | list[Feature]): The feature or list of features to use
                as the position. If the individual axes are stored in different
                attributes, this can be a list of Features. If the position is stored
                in a single attribute, this will be a single Feature.
            extra_features (list[Feature] | None, optional): Extra features
                to add to the set upon initalization. Defaults to None.
        """
        self.time = time_feature
        self.position: Feature | list[Feature] = pos_feature
        self._features: list[Feature] = []

        features = [self.time]
        if isinstance(self.position, Feature):
            features.append(self.position)
        else:
            features.extend(self.position)
        if extra_features is not None:
            features.extend(extra_features)
        for feat in features:
            self.add_feature(feat)

    @property
    def node_features(self) -> list[Feature]:
        """A list of all features present on nodes"""
        return [f for f in self._features if f.feature_type == FeatureType.NODE]

    @property
    def edge_features(self) -> list[Feature]:
        """A list of all features present on edges"""
        return [f for f in self._features if f.feature_type == FeatureType.EDGE]

    def add_feature(self, feature: Feature) -> None:
        """Add the given feature to this set of features. Checks for key collision.

        Args:
            feature (Feature): The feature to add to the set

        Raises:
            KeyError: If there is already a feature in the set with the same feature_type
                and key.
        """
        if feature.feature_type == FeatureType.NODE:
            existing_features = self.node_features
        elif feature.feature_type == FeatureType.EDGE:
            existing_features = self.edge_features

        if feature.key in [f.key for f in existing_features]:
            raise KeyError(f"Key {feature.key} already in feature set")
        self._features.append(feature)

    def dump_json(self) -> dict:
        """Dump this FeatureSet to a json compatible dictionary

        Returns:
            dict: A map from the key "FeatureSet" to a list of json representations of
                the features in this FeatureSet. The time and position are stored twice,
                once to denote which features represent time and position, and again in
                the generic list of all features.
        """
        pos_value = (
            self.position.model_dump(mode="json")
            if isinstance(self.position, Feature)
            else [feat.model_dump(mode="json") for feat in self.position]
        )
        set_dict = {
            "position": pos_value,
            "time": self.time.model_dump(mode="json"),
            "features": [feat.model_dump(mode="json") for feat in self._features],
        }
        return {"FeatureSet": set_dict}

    @classmethod
    def from_json(cls, json_dict: dict) -> FeatureSet:
        """Generate a FeatureSet from a json dict such as one generated by dump_json

        Args:
            json_dict (dict): A dictionary with the key "FeatureSet" mapping to a
                list of json representation of features. The time and position are stored
                twice, once to denote which features represent time and position, and
                again in the generic list of all features.

        Returns:
            FeatureSet: A FeatureSet object containing the features from the dictionary
        """
        feature_set = json_dict["FeatureSet"]
        position_vals = feature_set["position"]
        time_vals = feature_set["time"]
        feature_vals = feature_set["features"]

        features = FeatureSet.__new__(FeatureSet)
        features.time = Feature(**time_vals)
        if isinstance(position_vals, list):
            features.position = [Feature(**feat) for feat in position_vals]
        else:
            features.position = Feature(**position_vals)
        features._features = [Feature(**feat) for feat in feature_vals]
        return features

    def __repr__(self):  # pragma: no cover
        return str([repr(feature) for feature in self._features])
