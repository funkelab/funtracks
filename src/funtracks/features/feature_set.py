from __future__ import annotations

from .feature import Feature, FeatureType


class FeatureSet:
    """A class to keep track of and manipulate the Features available on a graph.

    Use this class to:

    - list all available (node/edge) features
    - add node/edge features so that they can be discovered by other parts of the
        application
    - conveniently access the features that have a specific meaning for the application
        (e.g. time, position)
    """

    def __init__(
        self,
        time_feature: Feature,
        pos_feature: Feature,
        extra_features: list[Feature] | None = None,
    ):
        """
        Args:
            time_feature (Feature): The feature to use as the time. Usually Time(),
                but can be given a different key.
            pos_feature (Feature): The feature to use as the position.
                Usually an instance of Position.
            extra_features (list[Feature] | None, optional): Extra features
                to add to the set upon initalization. Defaults to None.
        """
        self.time = time_feature
        self.position = pos_feature
        self._features: list[Feature] = []

        features = [self.time, self.position]
        if extra_features is not None:
            features.extend(extra_features)
        for feat in features:
            self.add_feature(feat)

    @property
    def node_features(self):
        """A list of all features present on nodes"""
        return [f for f in self._features if f.feature_type == FeatureType.NODE]

    @property
    def edge_features(self):
        """A list of all features present on edges"""
        return [f for f in self._features if f.feature_type == FeatureType.EDGE]

    def add_feature(self, feature: Feature):
        """Add the given feature to this set of features. Checks for key collision.

        Args:
            feature (Feature): The feature to add to the set

        Raises:
            KeyError: If there is already a feature in the set with the same feature_type
                and key.
        """
        if feature.feature_type == FeatureType.NODE:
            existing_features = self.node_features
        elif feature.feature_type == FeatureType.EDGE:
            existing_features = self.edge_features

        if feature.key in [f.key for f in existing_features]:
            raise KeyError(f"Key {feature.key} already in feature set")
        self._features.append(feature)

    def dump_json(self) -> dict:
        """Dump this FeatureSet to a json compatible dictionary

        Returns:
            dict: A map from the key "FeatureSet" to a list of json representations of
                the features in this FeatureSet. They must be in order:
                [time, position, ...]
        """
        return {"FeatureSet": [feat.model_dump(mode="json") for feat in self._features]}

    @classmethod
    def from_json(cls, json_dict: dict) -> FeatureSet:
        """Generate a FeatureSet from a json dict such as one generated by dump_json

        Args:
            json_dict (dict): A dictionary with the key "FeatureSet" mapping to a
                list of json representation of features. They must be in order:
                [time, position, ...]

        Returns:
            FeatureSet: A FeatureSet object containing the features from the dictionary
        """
        features_list = [Feature(**feat) for feat in json_dict["FeatureSet"]]
        (
            time,
            position,
        ) = features_list[0:2]
        features = FeatureSet.__new__(FeatureSet)
        features.time = time
        features.position = position
        features._features = features_list
        return features

    def __repr__(self):
        return str([repr(feature) for feature in self._features])
