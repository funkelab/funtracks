from __future__ import annotations

import json
import warnings
from pathlib import Path
from typing import TYPE_CHECKING

import networkx as nx
import numpy as np

from funtracks.features import FeatureDict
from funtracks.utils.tracksdata_utils import (
    add_masks_and_bboxes_to_graph,
    convert_graph_nx_to_td,
)

if TYPE_CHECKING:
    from ..data_model import SolutionTracks, Tracks

GRAPH_FILE = "graph.json"
SEG_FILE = "seg.npy"
ATTRS_FILE = "attrs.json"


def load_v1_tracks(
    directory: Path, seg_required: bool = False, solution: bool = False
) -> Tracks | SolutionTracks:
    """Load a Tracks object from the given directory. Looks for files
    in the format generated by Tracks.save.

    TODO: retain loading capabilities for legacy tracks

    Args:
        directory (Path): The directory containing tracks to load
        seg_required (bool, optional): If true, raises a FileNotFoundError if the
            segmentation file is not present in the directory. Defaults to False.
        solution (bool, optional): If true, returns a SolutionTracks object, otherwise
            returns a normal Tracks object. Defaults to False.

    Returns:
        Tracks: A tracks object loaded from the given directory
    """
    graph_file = directory / GRAPH_FILE
    graph_nx = _load_graph(graph_file)

    seg_file = directory / SEG_FILE
    seg = _load_seg(seg_file, seg_required=seg_required)

    attrs_file = directory / ATTRS_FILE
    attrs = _load_attrs(attrs_file)

    graph_td = convert_graph_nx_to_td(graph_nx)

    # Add mask and bbox attributes to graph if segmentation is available
    if seg is not None:
        graph_td = add_masks_and_bboxes_to_graph(graph_td, seg)

    segmentation_shape = seg.shape if seg is not None else None

    # filtering the warnings because the default values of time_attr and pos_attr are
    # not None. Therefore, new style Tracks attrs that have features instead of
    # pos_attr and time_attr will always trigger the warning. Updating default values
    # is breaking, and manually setting the attrs to None if features is present will
    # break if the attrs are changed/removed in the future. Can remove in v2.0.
    # Import at runtime to avoid circular dependency
    from ..data_model import SolutionTracks, Tracks

    with warnings.catch_warnings():
        warnings.filterwarnings(
            "ignore", message="Provided both FeatureDict and pos_attr or time_attr"
        )
        tracks: Tracks
        if solution:
            tracks = SolutionTracks(
                graph_td, segmentation_shape=segmentation_shape, **attrs
            )
        else:
            tracks = Tracks(graph_td, segmentation_shape=segmentation_shape, **attrs)
    return tracks


def _load_graph(graph_file: Path) -> nx.DiGraph:
    """Load the graph from the given json file. Expects networkx node_link_graph
    formatted json.

    Args:
        graph_file (Path): The json file to load into a networkx graph

    Raises:
        FileNotFoundError: If the file does not exist

    Returns:
        nx.DiGraph: A networkx graph loaded from the file.
    """
    if graph_file.is_file():
        with open(graph_file) as f:
            json_graph = json.load(f)
        return nx.node_link_graph(json_graph, directed=True, edges="links")
    else:
        raise FileNotFoundError(f"No graph at {graph_file}")


def _load_seg(seg_file: Path, seg_required: bool = False) -> np.ndarray | None:
    """Load a segmentation from a file. If the file doesn't exist, either return
    None or raise a FileNotFoundError depending on the seg_required flag.

    Args:
        seg_file (Path): The npz file to load.
        seg_required (bool, optional): If true, raise a FileNotFoundError if the
            segmentation is not present. Defaults to False.

    Returns:
        np.ndarray | None: The segmentation array, or None if it wasn't present and
            seg_required was False.
    """
    if seg_file.is_file():
        return np.load(seg_file)
    elif seg_required:
        raise FileNotFoundError(f"No segmentation at {seg_file}")
    else:
        return None


def _load_attrs(attrs_file: Path) -> dict:
    if attrs_file.is_file():
        with open(attrs_file) as f:
            json_dict = json.load(f)
        if "features" in json_dict:
            json_dict["features"] = FeatureDict.from_json(json_dict["features"])
        return json_dict

    else:
        raise FileNotFoundError(f"No attributes at {attrs_file}")


def delete_tracks(directory: Path | str):
    """Delete the tracks in the given directory. Also deletes the directory.

    Args:
        directory (Path | str): Path to a directory containing tracks
    """
    if not isinstance(directory, Path):
        directory = Path(directory)
    (directory / GRAPH_FILE).unlink()
    (directory / SEG_FILE).unlink(missing_ok=True)
    (directory / ATTRS_FILE).unlink()
    directory.rmdir()
