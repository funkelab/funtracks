{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Funtracks","text":"<p>A data model for cell tracking with actions, undo history, persistence, and more!</p> <p>Designed for use with the finn tracks viewer and motile tracker. Provides a data model for programmatic editing of tracks that can be used by a UI like finn or by a machine agent for active learning.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install funtracks</code></p> <p>Or use pixi!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Features already included in funtracks: - fully undo-able action history</p> <p>Features that will be included in funtracks: - both in-memory and out-of-memory tracks   - in-memory using networkx (slower, pure python) or spatial_graph (faster, compiled C) data structures   - out-of-memory using zarr for segmentations and SQLite/PostGreSQL for graphs - functions to import from and export to common file structures (csv, segmentation relabeled by track id) - generic features with the option to automatically update features on tracks editing actions</p>"},{"location":"reference/funtracks/","title":"funtracks","text":""},{"location":"reference/funtracks/#funtracks","title":"funtracks","text":"<p>Modules:</p> Name Description <code>data_model</code> <code>import_export</code>"},{"location":"reference/funtracks/data_model/","title":"data_model","text":""},{"location":"reference/funtracks/data_model/#funtracks.data_model","title":"funtracks.data_model","text":"<p>Modules:</p> Name Description <code>action_history</code> <code>actions</code> <p>This module contains all the low level actions used to control a Tracks object.</p> <code>compute_ious</code> <code>graph_attributes</code> <code>solution_tracks</code> <code>tracks</code> <code>tracks_controller</code>"},{"location":"reference/funtracks/data_model/action_history/","title":"action_history","text":""},{"location":"reference/funtracks/data_model/action_history/#funtracks.data_model.action_history","title":"funtracks.data_model.action_history","text":"<p>Classes:</p> Name Description <code>ActionHistory</code> <p>An action history implementing the ideas from this blog:</p>"},{"location":"reference/funtracks/data_model/action_history/#funtracks.data_model.action_history.ActionHistory","title":"ActionHistory","text":"<pre><code>ActionHistory()\n</code></pre> <p>An action history implementing the ideas from this blog: https://github.com/zaboople/klonk/blob/master/TheGURQ.md Essentially, if you go back and change something after undo-ing, you can always get back to every state if you undo far enough (instead of throwing out the undone actions)</p> <p>Methods:</p> Name Description <code>add_new_action</code> <p>Add a newly performed action to the history.</p> <code>redo</code> <p>Redo the last undone action</p> <code>undo</code> <p>Undo the last performed action</p> Source code in <code>src/funtracks/data_model/action_history.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.undo_stack: list[TracksAction] = []  # list of actions that can be undone\n    self.redo_stack: list[TracksAction] = []  # list of actions that can be redone\n</code></pre>"},{"location":"reference/funtracks/data_model/action_history/#funtracks.data_model.action_history.ActionHistory.add_new_action","title":"add_new_action","text":"<pre><code>add_new_action(action: TracksAction) -&gt; None\n</code></pre> <p>Add a newly performed action to the history. Args:     action (TracksAction): The new action to be added to the history.</p> Source code in <code>src/funtracks/data_model/action_history.py</code> <pre><code>def add_new_action(self, action: TracksAction) -&gt; None:\n    \"\"\"Add a newly performed action to the history.\n    Args:\n        action (TracksAction): The new action to be added to the history.\n    \"\"\"\n    if len(self.redo_stack) &gt; 0:\n        # add all the redo stuff to the undo stack, so that both the originial and\n        # inverse are on the stack\n        self.undo_stack.extend(self.redo_stack)\n        self.redo_stack = []\n    self.undo_stack.append(action)\n</code></pre>"},{"location":"reference/funtracks/data_model/action_history/#funtracks.data_model.action_history.ActionHistory.redo","title":"redo","text":"<pre><code>redo() -&gt; bool\n</code></pre> <p>Redo the last undone action</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if an action was redone, and False</p> <code>bool</code> <p>if there was no undone action to redo.</p> Source code in <code>src/funtracks/data_model/action_history.py</code> <pre><code>def redo(self) -&gt; bool:\n    \"\"\"Redo the last undone action\n\n    Returns:\n        bool: True if an action was redone, and False\n        if there was no undone action to redo.\n    \"\"\"\n    if len(self.redo_stack) == 0:\n        return False\n    else:\n        action = self.redo_stack.pop(-1)\n        # apply the inverse but don't save it\n        # (the original is already on the undo stack)\n        action.inverse()\n        return True\n</code></pre>"},{"location":"reference/funtracks/data_model/action_history/#funtracks.data_model.action_history.ActionHistory.undo","title":"undo","text":"<pre><code>undo() -&gt; bool\n</code></pre> <p>Undo the last performed action</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if an action was undone, and False</p> <code>bool</code> <p>if there was no previous action to undo.</p> Source code in <code>src/funtracks/data_model/action_history.py</code> <pre><code>def undo(self) -&gt; bool:\n    \"\"\"Undo the last performed action\n\n    Returns:\n        bool: True if an action was undone, and False\n        if there was no previous action to undo.\n    \"\"\"\n    if self._undo_pointer &lt; 0:\n        return False\n    else:\n        action = self.undo_stack[self._undo_pointer]\n        inverse = action.inverse()\n        self.redo_stack.append(inverse)\n        return True\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/","title":"actions","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions","title":"funtracks.data_model.actions","text":"<p>This module contains all the low level actions used to control a Tracks object. Low level actions should control these aspects of Tracks:     - adding/removing nodes and edges to/from the segmentation and graph     - Updating the segmentation and graph attributes that are controlled by the       segmentation. Currently, position and area for nodes, and IOU for edges.     - Keeping track of information needed to undo the given action. For removing a node,     this means keeping track of the incident edges that were removed, along with their     attributes.</p> <p>The low level actions do not contain application logic, such as manipulating track ids, or validation of \"allowed\" actions. The actions should work on candidate graphs as well as solution graphs. Action groups can be constructed to represent application-level actions constructed from many low-level actions.</p> <p>Classes:</p> Name Description <code>ActionGroup</code> <code>AddEdges</code> <p>Action for adding new edges</p> <code>AddNodes</code> <p>Action for adding new nodes. If a segmentation should also be added, the</p> <code>DeleteEdges</code> <p>Action for deleting edges</p> <code>DeleteNodes</code> <p>Action of deleting existing nodes</p> <code>TracksAction</code> <code>UpdateNodeAttrs</code> <p>Action for user updates to node attributes. Cannot update protected</p> <code>UpdateNodeSegs</code> <p>Action for updating the segmentation associated with nodes. Cannot mix adding</p> <code>UpdateTrackID</code>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.ActionGroup","title":"ActionGroup","text":"<pre><code>ActionGroup(tracks: Tracks, actions: list[TracksAction])\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>A group of actions that is also an action, used to modify the given tracks. This is useful for creating composite actions from the low-level actions. Composite actions can contain application logic and can be un-done as a group.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The tracks that this action will edit</p> required <code>list[TracksAction]</code> <p>A list of actions contained within the group, in the order in which they should be executed.</p> required Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(\n    self,\n    tracks: Tracks,\n    actions: list[TracksAction],\n):\n    \"\"\"A group of actions that is also an action, used to modify the given tracks.\n    This is useful for creating composite actions from the low-level actions.\n    Composite actions can contain application logic and can be un-done as a group.\n\n    Args:\n        tracks (Tracks): The tracks that this action will edit\n        actions (list[TracksAction]): A list of actions contained within the group,\n            in the order in which they should be executed.\n    \"\"\"\n    super().__init__(tracks)\n    self.actions = actions\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.ActionGroup(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.ActionGroup(actions)","title":"<code>actions</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddEdges","title":"AddEdges","text":"<pre><code>AddEdges(tracks: Tracks, edges: Iterable[Edge])\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action for adding new edges</p> <p>Methods:</p> Name Description <code>inverse</code> <p>Delete edges</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(self, tracks: Tracks, edges: Iterable[Edge]):\n    super().__init__(tracks)\n    self.edges = edges\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddEdges.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Delete edges</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Delete edges\"\"\"\n    return DeleteEdges(self.tracks, self.edges)\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes","title":"AddNodes","text":"<pre><code>AddNodes(tracks: Tracks, nodes: Iterable[Node], attributes: Attrs, pixels: Iterable[SegMask] | None = None)\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action for adding new nodes. If a segmentation should also be added, the pixels for each node should be provided. The label to set the pixels will be taken from the node id. The existing pixel values are assumed to be zero - you must explicitly update any other segmentations that were overwritten using an UpdateNodes action if you want to be able to undo the action.</p> <p>Create an action to add new nodes, with optional segmentation</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The Tracks to add the nodes to</p> required <code>Node</code> <p>A list of node ids</p> required <code>Attrs</code> <p>Includes times and optionally positions</p> required <code>list[SegMask] | None</code> <p>The segmentations associated with each node. Defaults to None.</p> <code>None</code> <p>Methods:</p> Name Description <code>inverse</code> <p>Invert the action to delete nodes instead</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(\n    self,\n    tracks: Tracks,\n    nodes: Iterable[Node],\n    attributes: Attrs,\n    pixels: Iterable[SegMask] | None = None,\n):\n    \"\"\"Create an action to add new nodes, with optional segmentation\n\n    Args:\n        tracks (Tracks): The Tracks to add the nodes to\n        nodes (Node): A list of node ids\n        attributes (Attrs): Includes times and optionally positions\n        pixels (list[SegMask] | None, optional): The segmentations associated with\n            each node. Defaults to None.\n    \"\"\"\n    super().__init__(tracks)\n    self.nodes = nodes\n    user_attrs = attributes.copy()\n    self.times = attributes.pop(NodeAttr.TIME.value, None)\n    self.positions = attributes.pop(NodeAttr.POS.value, None)\n    self.pixels = pixels\n    self.attributes = user_attrs\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes(attributes)","title":"<code>attributes</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes(pixels)","title":"<code>pixels</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.AddNodes.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Invert the action to delete nodes instead</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Invert the action to delete nodes instead\"\"\"\n    return DeleteNodes(self.tracks, self.nodes)\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.DeleteEdges","title":"DeleteEdges","text":"<pre><code>DeleteEdges(tracks: Tracks, edges: Iterable[Edge])\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action for deleting edges</p> <p>Methods:</p> Name Description <code>inverse</code> <p>Restore edges and their attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(self, tracks: Tracks, edges: Iterable[Edge]):\n    super().__init__(tracks)\n    self.edges = edges\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.DeleteEdges.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Restore edges and their attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Restore edges and their attributes\"\"\"\n    return AddEdges(self.tracks, self.edges)\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.DeleteNodes","title":"DeleteNodes","text":"<pre><code>DeleteNodes(tracks: Tracks, nodes: Iterable[Node], pixels: Iterable[SegMask] | None = None)\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action of deleting existing nodes If the tracks contain a segmentation, this action also constructs a reversible operation for setting involved pixels to zero</p> <p>Methods:</p> Name Description <code>inverse</code> <p>Invert this action, and provide inverse segmentation operation if given</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(\n    self,\n    tracks: Tracks,\n    nodes: Iterable[Node],\n    pixels: Iterable[SegMask] | None = None,\n):\n    super().__init__(tracks)\n    self.nodes = nodes\n    self.attributes = {\n        NodeAttr.TIME.value: self.tracks.get_times(nodes),\n        self.tracks.pos_attr: self.tracks.get_positions(nodes),\n        NodeAttr.TRACK_ID.value: self.tracks.get_nodes_attr(\n            nodes, NodeAttr.TRACK_ID.value\n        ),\n    }\n    self.pixels = self.tracks.get_pixels(nodes) if pixels is None else pixels\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.DeleteNodes.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Invert this action, and provide inverse segmentation operation if given</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Invert this action, and provide inverse segmentation operation if given\"\"\"\n\n    return AddNodes(self.tracks, self.nodes, self.attributes, pixels=self.pixels)\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.TracksAction","title":"TracksAction","text":"<pre><code>TracksAction(tracks: Tracks)\n</code></pre> <p>An modular change that can be applied to the given Tracks. The tracks must be passed in at construction time so that metadata needed to invert the action can be extracted. The change should be applied in the init function.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The tracks that this action will edit</p> required <p>Methods:</p> Name Description <code>inverse</code> <p>Get the inverse of this action. Calling this function does undo the action,</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(self, tracks: Tracks):\n    \"\"\"An modular change that can be applied to the given Tracks. The tracks must\n    be passed in at construction time so that metadata needed to invert the action\n    can be extracted.\n    The change should be applied in the init function.\n\n    Args:\n        tracks (Tracks): The tracks that this action will edit\n    \"\"\"\n    self.tracks = tracks\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.TracksAction(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.TracksAction.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; TracksAction\n</code></pre> <p>Get the inverse of this action. Calling this function does undo the action, since the change is applied in the action constructor.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the inverse is not implemented in the subclass</p> <p>Returns:</p> Name Type Description <code>TracksAction</code> <code>TracksAction</code> <p>An action that un-does this action, bringing the tracks back to the exact state it had before applying this action.</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self) -&gt; TracksAction:\n    \"\"\"Get the inverse of this action. Calling this function does undo the action,\n    since the change is applied in the action constructor.\n\n    Raises:\n        NotImplementedError: if the inverse is not implemented in the subclass\n\n    Returns:\n        TracksAction: An action that un-does this action, bringing the tracks\n            back to the exact state it had before applying this action.\n    \"\"\"\n    raise NotImplementedError(\"Inverse not implemented\")\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeAttrs","title":"UpdateNodeAttrs","text":"<pre><code>UpdateNodeAttrs(tracks: Tracks, nodes: Iterable[Node], attrs: Attrs)\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action for user updates to node attributes. Cannot update protected attributes (time, area, track id), as these are controlled by internal application logic.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The tracks to update the node attributes for</p> required <code>Iterable[Node]</code> <p>The nodes to update the attributes for</p> required <code>Attrs</code> <p>A mapping from attribute name to list of new attribute values for the given nodes.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a protected attribute is in the given attribute mapping.</p> <p>Methods:</p> Name Description <code>inverse</code> <p>Restore previous attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(\n    self,\n    tracks: Tracks,\n    nodes: Iterable[Node],\n    attrs: Attrs,\n):\n    \"\"\"\n    Args:\n        tracks (Tracks): The tracks to update the node attributes for\n        nodes (Iterable[Node]): The nodes to update the attributes for\n        attrs (Attrs): A mapping from attribute name to list of new attribute values\n            for the given nodes.\n\n    Raises:\n        ValueError: If a protected attribute is in the given attribute mapping.\n    \"\"\"\n    super().__init__(tracks)\n    protected_attrs = [\n        tracks.time_attr,\n        NodeAttr.AREA.value,\n        NodeAttr.TRACK_ID.value,\n    ]\n    for attr in attrs:\n        if attr in protected_attrs:\n            raise ValueError(f\"Cannot update attribute {attr} manually\")\n    self.nodes = nodes\n    self.prev_attrs = {\n        attr: self.tracks.get_nodes_attr(nodes, attr) for attr in attrs\n    }\n    self.new_attrs = attrs\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeAttrs(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeAttrs(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeAttrs(attrs)","title":"<code>attrs</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeAttrs.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Restore previous attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Restore previous attributes\"\"\"\n    return UpdateNodeAttrs(\n        self.tracks,\n        self.nodes,\n        self.prev_attrs,\n    )\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs","title":"UpdateNodeSegs","text":"<pre><code>UpdateNodeSegs(tracks: Tracks, nodes: Iterable[Node], pixels: Iterable[SegMask], added: bool = True)\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Action for updating the segmentation associated with nodes. Cannot mix adding and removing pixels from segmentation: the added flag applies to all nodes</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The tracks to update the segmenatations for</p> required <code>list[Node]</code> <p>The nodes with updated segmenatations</p> required <code>list[SegMask]</code> <p>The pixels that were updated for each node</p> required <code>bool</code> <p>If the provided pixels were added (True) or deleted (False) from all nodes. Defaults to True. Cannot mix adding and deleting pixels in one action.</p> <code>True</code> <p>Methods:</p> Name Description <code>inverse</code> <p>Restore previous attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(\n    self,\n    tracks: Tracks,\n    nodes: Iterable[Node],\n    pixels: Iterable[SegMask],\n    added: bool = True,\n):\n    \"\"\"\n    Args:\n        tracks (Tracks): The tracks to update the segmenatations for\n        nodes (list[Node]): The nodes with updated segmenatations\n        pixels (list[SegMask]): The pixels that were updated for each node\n        added (bool, optional): If the provided pixels were added (True) or deleted\n            (False) from all nodes. Defaults to True. Cannot mix adding and deleting\n            pixels in one action.\n    \"\"\"\n    super().__init__(tracks)\n    self.nodes = nodes\n    self.pixels = pixels\n    self.added = added\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs(pixels)","title":"<code>pixels</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs(added)","title":"<code>added</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateNodeSegs.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Restore previous attributes</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self):\n    \"\"\"Restore previous attributes\"\"\"\n    return UpdateNodeSegs(\n        self.tracks,\n        self.nodes,\n        pixels=self.pixels,\n        added=not self.added,\n    )\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateTrackID","title":"UpdateTrackID","text":"<pre><code>UpdateTrackID(tracks: SolutionTracks, start_node: Node, track_id: int)\n</code></pre> <p>               Bases: <code>TracksAction</code></p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>The tracks to update</p> required <code>Node</code> <p>The node ID of the first node in the track. All successors with the same track id as this node will be updated.</p> required <code>int</code> <p>The new track id to assign.</p> required <p>Methods:</p> Name Description <code>inverse</code> <p>Restore the previous track_id</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def __init__(self, tracks: SolutionTracks, start_node: Node, track_id: int):\n    \"\"\"\n    Args:\n        tracks (Tracks): The tracks to update\n        start_node (Node): The node ID of the first node in the track. All successors\n            with the same track id as this node will be updated.\n        track_id (int): The new track id to assign.\n    \"\"\"\n    super().__init__(tracks)\n    self.tracks: SolutionTracks = tracks\n    self.start_node = start_node\n    self.old_track_id = self.tracks.get_track_id(start_node)\n    self.new_track_id = track_id\n    self._apply()\n</code></pre>"},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateTrackID(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateTrackID(start_node)","title":"<code>start_node</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateTrackID(track_id)","title":"<code>track_id</code>","text":""},{"location":"reference/funtracks/data_model/actions/#funtracks.data_model.actions.UpdateTrackID.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; TracksAction\n</code></pre> <p>Restore the previous track_id</p> Source code in <code>src/funtracks/data_model/actions.py</code> <pre><code>def inverse(self) -&gt; TracksAction:\n    \"\"\"Restore the previous track_id\"\"\"\n    return UpdateTrackID(self.tracks, self.start_node, self.old_track_id)\n</code></pre>"},{"location":"reference/funtracks/data_model/compute_ious/","title":"compute_ious","text":""},{"location":"reference/funtracks/data_model/compute_ious/#funtracks.data_model.compute_ious","title":"funtracks.data_model.compute_ious","text":""},{"location":"reference/funtracks/data_model/graph_attributes/","title":"graph_attributes","text":""},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes","title":"funtracks.data_model.graph_attributes","text":"<p>Classes:</p> Name Description <code>EdgeAttr</code> <p>Edge attributes that can be added to candidate graph using the toolbox.</p> <code>NodeAttr</code> <p>Node attributes that can be added to candidate graph using the toolbox.</p> <code>NodeType</code> <p>Types of nodes in the track graph. Currently used for standardizing</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.EdgeAttr","title":"EdgeAttr","text":"<p>               Bases: <code>Enum</code></p> <p>Edge attributes that can be added to candidate graph using the toolbox. Note: Motile can flexibly support any custom attributes. The toolbox provides implementations of commonly used ones, listed here.</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.NodeAttr","title":"NodeAttr","text":"<p>               Bases: <code>Enum</code></p> <p>Node attributes that can be added to candidate graph using the toolbox. Note: Motile can flexibly support any custom attributes. The toolbox provides implementations of commonly used ones, listed here.</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.NodeType","title":"NodeType","text":"<p>               Bases: <code>Enum</code></p> <p>Types of nodes in the track graph. Currently used for standardizing visualization. All nodes are exactly one type.</p>"},{"location":"reference/funtracks/data_model/solution_tracks/","title":"solution_tracks","text":""},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks","title":"funtracks.data_model.solution_tracks","text":"<p>Classes:</p> Name Description <code>SolutionTracks</code> <p>Difference from Tracks: every node must have a track_id</p>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks","title":"SolutionTracks","text":"<pre><code>SolutionTracks(graph: DiGraph, segmentation: ndarray | None = None, time_attr: str = NodeAttr.TIME.value, pos_attr: str | tuple[str] | list[str] = NodeAttr.POS.value, scale: list[float] | None = None, ndim: int | None = None, recompute_track_ids: bool = True)\n</code></pre> <p>               Bases: <code>Tracks</code></p> <p>Difference from Tracks: every node must have a track_id</p> <p>Methods:</p> Name Description <code>export_tracks</code> <p>Export the tracks from this run to a csv with the following columns:</p> <code>get_next_track_id</code> <p>Return the next available track_id and update self.max_track_id</p> Source code in <code>src/funtracks/data_model/solution_tracks.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.DiGraph,\n    segmentation: np.ndarray | None = None,\n    time_attr: str = NodeAttr.TIME.value,\n    pos_attr: str | tuple[str] | list[str] = NodeAttr.POS.value,\n    scale: list[float] | None = None,\n    ndim: int | None = None,\n    recompute_track_ids: bool = True,\n):\n    super().__init__(\n        graph,\n        segmentation=segmentation,\n        time_attr=time_attr,\n        pos_attr=pos_attr,\n        scale=scale,\n        ndim=ndim,\n    )\n    self.max_track_id: int\n\n    # recompute track_id if requested or missing\n    if graph.number_of_nodes() == 0:\n        has_track_id = False\n    else:\n        has_track_id = NodeAttr.TRACK_ID.value in graph.nodes[next(iter(graph.nodes))]\n    if recompute_track_ids or not has_track_id:\n        self._initialize_track_ids()\n</code></pre>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.export_tracks","title":"export_tracks","text":"<pre><code>export_tracks(outfile: Path | str)\n</code></pre> <p>Export the tracks from this run to a csv with the following columns: t,[z],y,x,id,parent_id,track_id Cells without a parent_id will have an empty string for the parent_id. Whether or not to include z is inferred from self.ndim</p> Source code in <code>src/funtracks/data_model/solution_tracks.py</code> <pre><code>def export_tracks(self, outfile: Path | str):\n    \"\"\"Export the tracks from this run to a csv with the following columns:\n    t,[z],y,x,id,parent_id,track_id\n    Cells without a parent_id will have an empty string for the parent_id.\n    Whether or not to include z is inferred from self.ndim\n    \"\"\"\n    header = [\"t\", \"z\", \"y\", \"x\", \"id\", \"parent_id\", \"track_id\"]\n    if self.ndim == 3:\n        header = [header[0]] + header[2:]  # remove z\n    with open(outfile, \"w\") as f:\n        f.write(\",\".join(header))\n        for node_id in self.graph.nodes():\n            parents = list(self.graph.predecessors(node_id))\n            parent_id = \"\" if len(parents) == 0 else parents[0]\n            track_id = self.get_track_id(node_id)\n            time = self.get_time(node_id)\n            position = self.get_position(node_id)\n            row = [\n                time,\n                *position,\n                node_id,\n                parent_id,\n                track_id,\n            ]\n            f.write(\"\\n\")\n            f.write(\",\".join(map(str, row)))\n</code></pre>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.get_next_track_id","title":"get_next_track_id","text":"<pre><code>get_next_track_id() -&gt; int\n</code></pre> <p>Return the next available track_id and update self.max_track_id</p> Source code in <code>src/funtracks/data_model/solution_tracks.py</code> <pre><code>def get_next_track_id(self) -&gt; int:\n    \"\"\"Return the next available track_id and update self.max_track_id\"\"\"\n    if len(self.node_id_to_track_id) &gt; 0:\n        computed_max = max(self.node_id_to_track_id.values())\n        if self.max_track_id &lt; computed_max:\n            self.max_track_id = computed_max\n    else:\n        self.max_track_id = 0\n    self.max_track_id = self.max_track_id + 1\n    return self.max_track_id\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/","title":"tracks","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks","title":"funtracks.data_model.tracks","text":"<p>Classes:</p> Name Description <code>Tracks</code> <p>A set of tracks consisting of a graph and an optional segmentation.</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks","title":"Tracks","text":"<pre><code>Tracks(graph: DiGraph, segmentation: ndarray | None = None, time_attr: str = NodeAttr.TIME.value, pos_attr: str | tuple[str] | list[str] = NodeAttr.POS.value, scale: list[float] | None = None, ndim: int | None = None)\n</code></pre> <p>A set of tracks consisting of a graph and an optional segmentation. The graph nodes represent detections and must have a time attribute and position attribute. Edges in the graph represent links across time.</p> <p>Attributes:</p> Name Type Description <code>graph</code> <code>DiGraph</code> <p>A graph with nodes representing detections and and edges representing links across time.</p> <code>segmentation</code> <code>Optional(np.ndarray</code> <p>An optional segmentation that accompanies the tracking graph. If a segmentation is provided, the node ids in the graph must match the segmentation labels. Defaults to None.</p> <code>time_attr</code> <code>str</code> <p>The attribute in the graph that specifies the time frame each node is in.</p> <code>pos_attr</code> <code>str | tuple[str] | list[str]</code> <p>The attribute in the graph that specifies the position of each node. Can be a single attribute that holds a list, or a list of attribute keys.</p> <p>For bulk operations on attributes, a KeyError will be raised if a node or edge in the input set is not in the graph. All operations before the error node will be performed, and those after will not.</p> <p>Methods:</p> Name Description <code>delete</code> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <code>get_area</code> <p>Get the area/volume of a given node. Raises a KeyError if the node</p> <code>get_areas</code> <p>Get the area/volume of a given node. Raises a KeyError if the node</p> <code>get_pixels</code> <p>Get the pixels corresponding to each node in the nodes list.</p> <code>get_positions</code> <p>Get the positions of nodes in the graph. Optionally include the</p> <code>get_time</code> <p>Get the time frame of a given node. Raises an error if the node</p> <code>load</code> <p>Load a Tracks object from the given directory. Looks for files</p> <code>save</code> <p>Save the tracks to the given directory.</p> <code>set_pixels</code> <p>Set the given pixels in the segmentation to the given value.</p> <code>set_positions</code> <p>Set the location of nodes in the graph. Optionally include the</p> <code>set_time</code> <p>Set the time frame of a given node. Raises an error if the node</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.DiGraph,\n    segmentation: np.ndarray | None = None,\n    time_attr: str = NodeAttr.TIME.value,\n    pos_attr: str | tuple[str] | list[str] = NodeAttr.POS.value,\n    scale: list[float] | None = None,\n    ndim: int | None = None,\n):\n    self.graph = graph\n    self.segmentation = segmentation\n    self.time_attr = time_attr\n    self.pos_attr = pos_attr\n    self.scale = scale\n    self.ndim = self._compute_ndim(segmentation, scale, ndim)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.delete","title":"delete  <code>classmethod</code>","text":"<pre><code>delete(directory: Path)\n</code></pre> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>Directory containing tracks to be deleted</p> required Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>@classmethod\ndef delete(cls, directory: Path):\n    \"\"\"Delete the tracks in the given directory. Also deletes the directory.\n\n    Args:\n        directory (Path): Directory containing tracks to be deleted\n    \"\"\"\n    warn(\n        \"`Tracks.delete` is deprecated and will be removed in 2.0, use \"\n        \"`funtracks.import_export.internal_format.delete` instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    from ..import_export.internal_format import delete_tracks\n\n    delete_tracks(directory)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.delete(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_area","title":"get_area","text":"<pre><code>get_area(node: Node) -&gt; int | None\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>Parameters:</p> Name Type Description Default <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int | None</code> <p>The area/volume of the node</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def get_area(self, node: Node) -&gt; int | None:\n    \"\"\"Get the area/volume of a given node. Raises a KeyError if the node\n    is not in the graph. Returns None if the given node does not have an Area\n    attribute.\n\n    Args:\n        node (Node): The node id to get the area/volume for\n\n    Returns:\n        int: The area/volume of the node\n    \"\"\"\n    return self.get_areas([node])[0]\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_area(node)","title":"<code>node</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_areas","title":"get_areas","text":"<pre><code>get_areas(nodes: Iterable[Node]) -&gt; Sequence[int | None]\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>Parameters:</p> Name Type Description Default <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Sequence[int | None]</code> <p>The area/volume of the node</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def get_areas(self, nodes: Iterable[Node]) -&gt; Sequence[int | None]:\n    \"\"\"Get the area/volume of a given node. Raises a KeyError if the node\n    is not in the graph. Returns None if the given node does not have an Area\n    attribute.\n\n    Args:\n        node (Node): The node id to get the area/volume for\n\n    Returns:\n        int: The area/volume of the node\n    \"\"\"\n    return self.get_nodes_attr(nodes, NodeAttr.AREA.value)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_areas(node)","title":"<code>node</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_pixels","title":"get_pixels","text":"<pre><code>get_pixels(nodes: Iterable[Node]) -&gt; list[tuple[np.ndarray, ...]] | None\n</code></pre> <p>Get the pixels corresponding to each node in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>list[Node]</code> <p>A list of node to get the values for.</p> required <p>Returns:</p> Type Description <code>list[tuple[ndarray, ...]] | None</code> <p>list[tuple[np.ndarray, ...]] | None: A list of tuples, where each tuple</p> <code>list[tuple[ndarray, ...]] | None</code> <p>represents the pixels for one of the input nodes, or None if the segmentation</p> <code>list[tuple[ndarray, ...]] | None</code> <p>is None. The tuple will have length equal to the number of segmentation</p> <code>list[tuple[ndarray, ...]] | None</code> <p>dimensions, and can be used to index the segmentation.</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def get_pixels(self, nodes: Iterable[Node]) -&gt; list[tuple[np.ndarray, ...]] | None:\n    \"\"\"Get the pixels corresponding to each node in the nodes list.\n\n    Args:\n        nodes (list[Node]): A list of node to get the values for.\n\n    Returns:\n        list[tuple[np.ndarray, ...]] | None: A list of tuples, where each tuple\n        represents the pixels for one of the input nodes, or None if the segmentation\n        is None. The tuple will have length equal to the number of segmentation\n        dimensions, and can be used to index the segmentation.\n    \"\"\"\n    if self.segmentation is None:\n        return None\n    pix_list = []\n    for node in nodes:\n        time = self.get_time(node)\n        loc_pixels = np.nonzero(self.segmentation[time] == node)\n        time_array = np.ones_like(loc_pixels[0]) * time\n        pix_list.append((time_array, *loc_pixels))\n    return pix_list\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_pixels(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_positions","title":"get_positions","text":"<pre><code>get_positions(nodes: Iterable[Node], incl_time: bool = False) -&gt; np.ndarray\n</code></pre> <p>Get the positions of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[Node]</code> <p>The node ids in the graph to get the positions of</p> required <code>bool</code> <p>If true, include the time as the first element of each position array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A N x ndim numpy array holding the positions, where N is the number of nodes passed in</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def get_positions(self, nodes: Iterable[Node], incl_time: bool = False) -&gt; np.ndarray:\n    \"\"\"Get the positions of nodes in the graph. Optionally include the\n    time frame as the first dimension. Raises an error if any of the nodes\n    are not in the graph.\n\n    Args:\n        node (Iterable[Node]): The node ids in the graph to get the positions of\n        incl_time (bool, optional): If true, include the time as the\n            first element of each position array. Defaults to False.\n\n    Returns:\n        np.ndarray: A N x ndim numpy array holding the positions, where N is the\n            number of nodes passed in\n    \"\"\"\n    if isinstance(self.pos_attr, tuple | list):\n        positions = np.stack(\n            [self.get_nodes_attr(nodes, dim, required=True) for dim in self.pos_attr],\n            axis=1,\n        )\n    else:\n        positions = np.array(self.get_nodes_attr(nodes, self.pos_attr, required=True))\n\n    if incl_time:\n        times = np.array(self.get_nodes_attr(nodes, self.time_attr, required=True))\n        positions = np.c_[times, positions]\n\n    return positions\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_positions(node)","title":"<code>node</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_positions(incl_time)","title":"<code>incl_time</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_time","title":"get_time","text":"<pre><code>get_time(node: Node) -&gt; int\n</code></pre> <p>Get the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The node id to get the time frame for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The time frame that the node is in</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def get_time(self, node: Node) -&gt; int:\n    \"\"\"Get the time frame of a given node. Raises an error if the node\n    is not in the graph.\n\n    Args:\n        node (Any): The node id to get the time frame for\n\n    Returns:\n        int: The time frame that the node is in\n    \"\"\"\n    return int(self.get_times([node])[0])\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_time(node)","title":"<code>node</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(directory: Path, seg_required=False, solution=False) -&gt; Tracks\n</code></pre> <p>Load a Tracks object from the given directory. Looks for files in the format generated by Tracks.save. Args:     directory (Path): The directory containing tracks to load     seg_required (bool, optional): If true, raises a FileNotFoundError if the         segmentation file is not present in the directory. Defaults to False. Returns:     Tracks: A tracks object loaded from the given directory</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>@classmethod\ndef load(cls, directory: Path, seg_required=False, solution=False) -&gt; Tracks:\n    \"\"\"Load a Tracks object from the given directory. Looks for files\n    in the format generated by Tracks.save.\n    Args:\n        directory (Path): The directory containing tracks to load\n        seg_required (bool, optional): If true, raises a FileNotFoundError if the\n            segmentation file is not present in the directory. Defaults to False.\n    Returns:\n        Tracks: A tracks object loaded from the given directory\n    \"\"\"\n    warn(\n        \"`Tracks.load` is deprecated and will be removed in 2.0, use \"\n        \"`funtracks.import_export.internal_format.load` instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    from ..import_export.internal_format import load_tracks\n\n    return load_tracks(directory, seg_required=seg_required, solution=solution)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.save","title":"save","text":"<pre><code>save(directory: Path)\n</code></pre> <p>Save the tracks to the given directory. Currently, saves the graph as a json file in networkx node link data format, saves the segmentation as a numpy npz file, and saves the time and position attributes and scale information in an attributes json file. Args:     directory (Path): The directory to save the tracks in.</p> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def save(self, directory: Path):\n    \"\"\"Save the tracks to the given directory.\n    Currently, saves the graph as a json file in networkx node link data format,\n    saves the segmentation as a numpy npz file, and saves the time and position\n    attributes and scale information in an attributes json file.\n    Args:\n        directory (Path): The directory to save the tracks in.\n    \"\"\"\n    warn(\n        \"`Tracks.save` is deprecated and will be removed in 2.0, use \"\n        \"`funtracks.import_export.internal_format.save` instead\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    from ..import_export.internal_format import save_tracks\n\n    save_tracks(self, directory)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_pixels","title":"set_pixels","text":"<pre><code>set_pixels(pixels: Iterable[tuple[ndarray, ...]], values: Iterable[int | None])\n</code></pre> <p>Set the given pixels in the segmentation to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[tuple[ndarray]]</code> <p>The pixels that should be set, formatted like the output of np.nonzero (each element of the tuple represents one dimension, containing an array of indices in that dimension). Can be used to directly index the segmentation.</p> required <code>Iterable[int | None]</code> <p>The value to set each pixel to</p> required Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def set_pixels(\n    self, pixels: Iterable[tuple[np.ndarray, ...]], values: Iterable[int | None]\n):\n    \"\"\"Set the given pixels in the segmentation to the given value.\n\n    Args:\n        pixels (Iterable[tuple[np.ndarray]]): The pixels that should be set,\n            formatted like the output of np.nonzero (each element of the tuple\n            represents one dimension, containing an array of indices in that\n            dimension). Can be used to directly index the segmentation.\n        value (Iterable[int | None]): The value to set each pixel to\n    \"\"\"\n    if self.segmentation is None:\n        raise ValueError(\"Cannot set pixels when segmentation is None\")\n    for pix, val in zip(pixels, values, strict=False):\n        if val is None:\n            raise ValueError(\"Cannot set pixels to None value\")\n        self.segmentation[pix] = val\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_pixels(pixels)","title":"<code>pixels</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_pixels(value)","title":"<code>value</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_positions","title":"set_positions","text":"<pre><code>set_positions(nodes: Iterable[Node], positions: ndarray, incl_time: bool = False)\n</code></pre> <p>Set the location of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[node]</code> <p>The node ids in the graph to set the location of.</p> required <code>ndarray</code> <p>An (ndim, num_nodes) shape array of positions to set.</p> required <code>bool</code> <p>If true, include the time as the first column of the position array. Defaults to False.</p> <code>False</code> Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def set_positions(\n    self,\n    nodes: Iterable[Node],\n    positions: np.ndarray,\n    incl_time: bool = False,\n):\n    \"\"\"Set the location of nodes in the graph. Optionally include the\n    time frame as the first dimension. Raises an error if any of the nodes\n    are not in the graph.\n\n    Args:\n        nodes (Iterable[node]): The node ids in the graph to set the location of.\n        positions (np.ndarray): An (ndim, num_nodes) shape array of positions to set.\n        f incl_time is true, time is the first column and is included in ndim.\n        incl_time (bool, optional): If true, include the time as the\n            first column of the position array. Defaults to False.\n    \"\"\"\n    if not isinstance(positions, np.ndarray):\n        positions = np.array(positions)\n    if incl_time:\n        times = positions[:, 0].tolist()  # we know this is a list of ints\n        self.set_times(nodes, times)  # type: ignore\n        positions = positions[:, 1:]\n\n    if isinstance(self.pos_attr, tuple | list):\n        for idx, attr in enumerate(self.pos_attr):\n            self._set_nodes_attr(nodes, attr, positions[:, idx].tolist())\n    else:\n        self._set_nodes_attr(nodes, self.pos_attr, positions.tolist())\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_positions(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_positions(positions)","title":"<code>positions</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_positions(incl_time)","title":"<code>incl_time</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_time","title":"set_time","text":"<pre><code>set_time(node: Any, time: int)\n</code></pre> <p>Set the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The node id to set the time frame for</p> required <code>int</code> <p>The time to set</p> required Source code in <code>src/funtracks/data_model/tracks.py</code> <pre><code>def set_time(self, node: Any, time: int):\n    \"\"\"Set the time frame of a given node. Raises an error if the node\n    is not in the graph.\n\n    Args:\n        node (Any): The node id to set the time frame for\n        time (int): The time to set\n\n    \"\"\"\n    self.set_times([node], [int(time)])\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_time(node)","title":"<code>node</code>","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_time(time)","title":"<code>time</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/","title":"tracks_controller","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller","title":"funtracks.data_model.tracks_controller","text":"<p>Classes:</p> Name Description <code>TracksController</code> <p>A set of high level functions to change the data model.</p>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController","title":"TracksController","text":"<pre><code>TracksController(tracks: SolutionTracks)\n</code></pre> <p>A set of high level functions to change the data model. All changes to the data should go through this API.</p> <p>Methods:</p> Name Description <code>add_edges</code> <p>Add edges to the graph. Also update the track ids and</p> <code>add_nodes</code> <p>Calls the _add_nodes function to add nodes. Calls the refresh signal when</p> <code>delete_edges</code> <p>Delete edges from the graph.</p> <code>delete_nodes</code> <p>Calls the _delete_nodes function and then emits the refresh signal</p> <code>is_valid</code> <p>Check if this edge is valid.</p> <code>redo</code> <p>Obtain the action to redo from the history</p> <code>undo</code> <p>Obtain the action to undo from the history, and invert.</p> <code>update_node_attrs</code> <p>Update the user provided node attributes (not the managed attributes).</p> <code>update_segmentations</code> <p>Handle a change in the segmentation mask, checking for node addition,</p> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def __init__(self, tracks: SolutionTracks):\n    self.tracks = tracks\n    self.action_history = ActionHistory()\n    self.node_id_counter = 1\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_edges","title":"add_edges","text":"<pre><code>add_edges(edges: Iterable[Edge]) -&gt; None\n</code></pre> <p>Add edges to the graph. Also update the track ids and corresponding segmentations if applicable</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[Edge]</code> <p>An iterable of edges, each with source and target node ids</p> required Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def add_edges(self, edges: Iterable[Edge]) -&gt; None:\n    \"\"\"Add edges to the graph. Also update the track ids and\n    corresponding segmentations if applicable\n\n    Args:\n        edges (Iterable[Edge]): An iterable of edges, each with source and target\n            node ids\n    \"\"\"\n    make_valid_actions = []\n    for edge in edges:\n        is_valid, valid_action = self.is_valid(edge)\n        if not is_valid:\n            # warning was printed with details in is_valid call\n            return\n        if valid_action is not None:\n            make_valid_actions.append(valid_action)\n    main_action = self._add_edges(edges)\n    action: TracksAction\n    if len(make_valid_actions) &gt; 0:\n        make_valid_actions.append(main_action)\n        action = ActionGroup(self.tracks, make_valid_actions)\n    else:\n        action = main_action\n    self.action_history.add_new_action(action)\n    self.tracks.refresh.emit()\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_edges(edges)","title":"<code>edges</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(attributes: Attrs, pixels: list[SegMask] | None = None) -&gt; None\n</code></pre> <p>Calls the _add_nodes function to add nodes. Calls the refresh signal when finished.</p> <p>Parameters:</p> Name Type Description Default <code>Attrs</code> <p>dictionary containing at least time and position attributes</p> required <code>list[SegMask] | None</code> <p>The pixels associated with each node, if a segmentation is present. Defaults to None.</p> <code>None</code> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def add_nodes(\n    self,\n    attributes: Attrs,\n    pixels: list[SegMask] | None = None,\n) -&gt; None:\n    \"\"\"Calls the _add_nodes function to add nodes. Calls the refresh signal when\n    finished.\n\n    Args:\n        attributes (Attrs): dictionary containing at least time and position\n            attributes\n        pixels (list[SegMask] | None, optional): The pixels associated with each\n            node, if a segmentation is present. Defaults to None.\n    \"\"\"\n    result = self._add_nodes(attributes, pixels)\n    if result is not None:\n        action, nodes = result\n        self.action_history.add_new_action(action)\n        self.tracks.refresh.emit(nodes[0] if nodes else None)\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_nodes(attributes)","title":"<code>attributes</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_nodes(pixels)","title":"<code>pixels</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_edges","title":"delete_edges","text":"<pre><code>delete_edges(edges: Iterable[Edge])\n</code></pre> <p>Delete edges from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[Edge]</code> <p>The Nx2 array of edges to be deleted</p> required Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def delete_edges(self, edges: Iterable[Edge]):\n    \"\"\"Delete edges from the graph.\n\n    Args:\n        edges (Iterable[Edge]): The Nx2 array of edges to be deleted\n    \"\"\"\n\n    for edge in edges:\n        # First check if the to be deleted edges exist\n        if not self.tracks.graph.has_edge(edge[0], edge[1]):\n            warn(\"Cannot delete non-existing edge!\", stacklevel=2)\n            return\n    action = self._delete_edges(edges)\n    self.action_history.add_new_action(action)\n    self.tracks.refresh.emit()\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_edges(edges)","title":"<code>edges</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_nodes","title":"delete_nodes","text":"<pre><code>delete_nodes(nodes: Iterable[Node]) -&gt; None\n</code></pre> <p>Calls the _delete_nodes function and then emits the refresh signal</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[Node]</code> <p>array of node_ids to be deleted</p> required Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def delete_nodes(self, nodes: Iterable[Node]) -&gt; None:\n    \"\"\"Calls the _delete_nodes function and then emits the refresh signal\n\n    Args:\n        nodes (Iterable[Node]): array of node_ids to be deleted\n    \"\"\"\n\n    action = self._delete_nodes(nodes)\n    self.action_history.add_new_action(action)\n    self.tracks.refresh.emit()\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_nodes(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.is_valid","title":"is_valid","text":"<pre><code>is_valid(edge: Edge) -&gt; tuple[bool, TracksAction | None]\n</code></pre> <p>Check if this edge is valid. Criteria: - not horizontal - not existing yet - no merges - no triple divisions - new edge should be the shortest possible connection between two nodes, given     their track_ids (no skipping/bypassing any nodes of the same track_id).     Check if there are any nodes of the same source or target track_id between     source and target</p> <p>Parameters:</p> Name Type Description Default <code>Edge</code> <p>edge to be validated</p> required <p>Returns:</p> Type Description <code>tuple[bool, TracksAction | None]</code> <p>True if the edge is valid, false if invalid</p> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def is_valid(self, edge: Edge) -&gt; tuple[bool, TracksAction | None]:\n    \"\"\"Check if this edge is valid.\n    Criteria:\n    - not horizontal\n    - not existing yet\n    - no merges\n    - no triple divisions\n    - new edge should be the shortest possible connection between two nodes, given\n        their track_ids (no skipping/bypassing any nodes of the same track_id).\n        Check if there are any nodes of the same source or target track_id between\n        source and target\n\n    Args:\n        edge (Edge): edge to be validated\n\n    Returns:\n        True if the edge is valid, false if invalid\"\"\"\n\n    # make sure that the node2 is downstream of node1\n    time1 = self.tracks.get_time(edge[0])\n    time2 = self.tracks.get_time(edge[1])\n\n    if time1 &gt; time2:\n        edge = (edge[1], edge[0])\n        time1, time2 = time2, time1\n    action = None\n    # do all checks\n    # reject if edge already exists\n    if self.tracks.graph.has_edge(edge[0], edge[1]):\n        warn(\"Edge is rejected because it exists already.\", stacklevel=2)\n        return False, action\n\n    # reject if edge is horizontal\n    elif self.tracks.get_time(edge[0]) == self.tracks.get_time(edge[1]):\n        warn(\"Edge is rejected because it is horizontal.\", stacklevel=2)\n        return False, action\n\n    # reject if target node already has an incoming edge\n    elif self.tracks.graph.in_degree(edge[1]) &gt; 0:\n        warn(\n            \"Edge is rejected because merges are currently not allowed.\", stacklevel=2\n        )\n        return False, action\n\n    elif self.tracks.graph.out_degree(edge[0]) &gt; 1:\n        warn(\n            \"Edge is rejected because triple divisions are currently not allowed.\",\n            stacklevel=2,\n        )\n        return False, action\n\n    elif time2 - time1 &gt; 1:\n        track_id2 = self.tracks.graph.nodes[edge[1]][NodeAttr.TRACK_ID.value]\n        # check whether there are already any nodes with the same track id between\n        # source and target (shortest path between equal track_ids rule)\n        for t in range(time1 + 1, time2):\n            nodes = [\n                n\n                for n, attr in self.tracks.graph.nodes(data=True)\n                if attr.get(self.tracks.time_attr) == t\n                and attr.get(NodeAttr.TRACK_ID.value) == track_id2\n            ]\n            if len(nodes) &gt; 0:\n                warn(\"Please connect to the closest node\", stacklevel=2)\n                return False, action\n\n    # all checks passed!\n    return True, action\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.is_valid(edge)","title":"<code>edge</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.redo","title":"redo","text":"<pre><code>redo() -&gt; bool\n</code></pre> <p>Obtain the action to redo from the history Returns:     bool: True if the action was re-done, False if there were no more actions</p> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def redo(self) -&gt; bool:\n    \"\"\"Obtain the action to redo from the history\n    Returns:\n        bool: True if the action was re-done, False if there were no more actions\n    \"\"\"\n    if self.action_history.redo():\n        self.tracks.refresh.emit()\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.undo","title":"undo","text":"<pre><code>undo() -&gt; bool\n</code></pre> <p>Obtain the action to undo from the history, and invert. Returns:     bool: True if the action was undone, False if there were no more actions</p> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def undo(self) -&gt; bool:\n    \"\"\"Obtain the action to undo from the history, and invert.\n    Returns:\n        bool: True if the action was undone, False if there were no more actions\n    \"\"\"\n    if self.action_history.undo():\n        self.tracks.refresh.emit()\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(nodes: Iterable[Node], attributes: Attrs)\n</code></pre> <p>Update the user provided node attributes (not the managed attributes). Also adds the action to the history and emits the refresh signal.</p> <p>Parameters:</p> Name Type Description Default <code>Iterable[Node]</code> <p>The nodes to update the attributes for</p> required <code>Attrs</code> <p>A mapping from user-provided attributes to values for each node.</p> required Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def update_node_attrs(self, nodes: Iterable[Node], attributes: Attrs):\n    \"\"\"Update the user provided node attributes (not the managed attributes).\n    Also adds the action to the history and emits the refresh signal.\n\n    Args:\n        nodes (Iterable[Node]): The nodes to update the attributes for\n        attributes (Attrs): A mapping from user-provided attributes to values for\n            each node.\n    \"\"\"\n    action = self._update_node_attrs(nodes, attributes)\n    self.action_history.add_new_action(action)\n    self.tracks.refresh.emit()\n</code></pre>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_node_attrs(nodes)","title":"<code>nodes</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_node_attrs(attributes)","title":"<code>attributes</code>","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_segmentations","title":"update_segmentations","text":"<pre><code>update_segmentations(to_remove: list[tuple[Node, SegMask]], to_update_smaller: list[tuple[Node, SegMask]], to_update_bigger: list[tuple[Node, SegMask]], to_add: list[tuple[Node, int, SegMask]], current_timepoint: int) -&gt; None\n</code></pre> <p>Handle a change in the segmentation mask, checking for node addition, deletion, and attribute updates. Args:     to_remove (list[tuple[Node, SegMask]]): (node_ids, pixels)     to_update_smaller (list[tuple[Node, SegMask]]): (node_id, pixels)     to_update_bigger (list[tuple[Node, SegMask]]): (node_id, pixels)     to_add (list[tuple[Node, int, SegMask]]): (node_id, track_id, pixels)     current_timepoint (int): the current time point in the viewer, used to set         the selected node.</p> Source code in <code>src/funtracks/data_model/tracks_controller.py</code> <pre><code>def update_segmentations(\n    self,\n    to_remove: list[tuple[Node, SegMask]],\n    to_update_smaller: list[tuple[Node, SegMask]],\n    to_update_bigger: list[tuple[Node, SegMask]],\n    to_add: list[tuple[Node, int, SegMask]],\n    current_timepoint: int,\n) -&gt; None:\n    \"\"\"Handle a change in the segmentation mask, checking for node addition,\n    deletion, and attribute updates.\n    Args:\n        to_remove (list[tuple[Node, SegMask]]): (node_ids, pixels)\n        to_update_smaller (list[tuple[Node, SegMask]]): (node_id, pixels)\n        to_update_bigger (list[tuple[Node, SegMask]]): (node_id, pixels)\n        to_add (list[tuple[Node, int, SegMask]]): (node_id, track_id, pixels)\n        current_timepoint (int): the current time point in the viewer, used to set\n            the selected node.\n    \"\"\"\n    actions: list[TracksAction] = []\n    node_to_select = None\n\n    if len(to_remove) &gt; 0:\n        nodes = [node_id for node_id, _ in to_remove]\n        pixels = [pixels for _, pixels in to_remove]\n        actions.append(self._delete_nodes(nodes, pixels=pixels))\n    if len(to_update_smaller) &gt; 0:\n        nodes = [node_id for node_id, _ in to_update_smaller]\n        pixels = [pixels for _, pixels in to_update_smaller]\n        actions.append(self._update_node_segs(nodes, pixels, added=False))\n    if len(to_update_bigger) &gt; 0:\n        nodes = [node_id for node_id, _ in to_update_bigger]\n        pixels = [pixels for _, pixels in to_update_bigger]\n        actions.append(self._update_node_segs(nodes, pixels, added=True))\n    if len(to_add) &gt; 0:\n        nodes = [node for node, _, _ in to_add]\n        pixels = [pix for _, _, pix in to_add]\n        track_ids = [\n            val if val is not None else self.tracks.get_next_track_id()\n            for _, val, _ in to_add\n        ]\n        times = [pix[0][0] for pix in pixels]\n        attributes = {\n            NodeAttr.TRACK_ID.value: track_ids,\n            NodeAttr.TIME.value: times,\n            \"node_id\": nodes,\n        }\n\n        result = self._add_nodes(attributes=attributes, pixels=pixels)\n        if result is None:\n            return\n        else:\n            action, nodes = result\n\n        actions.append(action)\n\n        # if this is the time point where the user added a node, select the new node\n        if current_timepoint in times:\n            index = times.index(current_timepoint)\n            node_to_select = nodes[index]\n\n    action_group = ActionGroup(self.tracks, actions)\n    self.action_history.add_new_action(action_group)\n    self.tracks.refresh.emit(node_to_select)\n</code></pre>"},{"location":"reference/funtracks/import_export/","title":"import_export","text":""},{"location":"reference/funtracks/import_export/#funtracks.import_export","title":"funtracks.import_export","text":"<p>Modules:</p> Name Description <code>export_to_geff</code> <code>import_from_geff</code> <code>internal_format</code> <code>magic_imread</code> <p>Adapted implementation of napari.napari_builtins.io._read.magic_imread</p>"},{"location":"reference/funtracks/import_export/export_to_geff/","title":"export_to_geff","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff","title":"funtracks.import_export.export_to_geff","text":"<p>Functions:</p> Name Description <code>export_to_geff</code> <p>Export the Tracks nxgraph to geff.</p> <code>split_position_attr</code> <p>Spread the spatial coordinates to separate node attrs in order to export to geff</p>"},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.export_to_geff","title":"export_to_geff","text":"<pre><code>export_to_geff(tracks: Tracks, directory: Path, overwrite: bool = False)\n</code></pre> <p>Export the Tracks nxgraph to geff.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>Tracks object containing a graph to save.</p> required <code>Path</code> <p>Destination directory for saving the Zarr.</p> required <code>bool</code> <p>If True, allows writing into a non-empty directory.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid, parent doesn't exist, is not a directory,         or if the directory is not empty and overwrite is False.</p> Source code in <code>src/funtracks/import_export/export_to_geff.py</code> <pre><code>def export_to_geff(tracks: Tracks, directory: Path, overwrite: bool = False):\n    \"\"\"Export the Tracks nxgraph to geff.\n\n    Args:\n        tracks (Tracks): Tracks object containing a graph to save.\n        directory (Path): Destination directory for saving the Zarr.\n        overwrite (bool): If True, allows writing into a non-empty directory.\n\n    Raises:\n        ValueError: If the path is invalid, parent doesn't exist, is not a directory,\n                    or if the directory is not empty and overwrite is False.\n    \"\"\"\n    directory = directory.resolve(strict=False)\n\n    # Ensure parent directory exists\n    parent = directory.parent\n    if not parent.exists():\n        raise ValueError(f\"Parent directory {parent} does not exist.\")\n\n    # Check target directory\n    if directory.exists():\n        if not directory.is_dir():\n            raise ValueError(f\"Provided path {directory} exists but is not a directory.\")\n        if any(directory.iterdir()) and not overwrite:\n            raise ValueError(\n                f\"Directory {directory} is not empty. Use overwrite=True to allow export.\"\n            )\n    else:\n        # Create dir\n        directory.mkdir()\n\n    # update the graph to split the position into separate attrs, if they are currently\n    # together in a list\n    if isinstance(tracks.pos_attr, str):\n        graph = split_position_attr(tracks)\n        axis_names = (\n            [tracks.time_attr, \"y\", \"x\"]\n            if tracks.ndim == 3\n            else [tracks.time_attr, \"z\", \"y\", \"x\"]\n        )\n    else:\n        graph = tracks.graph\n        axis_names = list(tracks.pos_attr)\n        axis_names.insert(0, tracks.time_attr)\n\n    axis_types = (\n        [\"time\", \"space\", \"space\"]\n        if tracks.ndim == 3\n        else [\"time\", \"space\", \"space\", \"space\"]\n    )\n\n    # calculate affine matrix\n    if tracks.scale is None:\n        tracks.scale = (1.0,) * tracks.ndim\n    linear_matrix = np.diag(tracks.scale)\n    offset = 0.0  # no offset or translation\n    affine = Affine.from_matrix_offset(linear_matrix, offset)\n\n    # Create metadata and add the affine matrix. Axes will be added automatically.\n    metadata = GeffMetadata(\n        geff_version=geff.__version__,\n        directed=isinstance(graph, nx.DiGraph),\n        affine=affine,\n    )\n\n    # Save segmentation if present\n    if tracks.segmentation is not None:\n        seg_path = directory / \"segmentation\"\n        seg_path.mkdir(exist_ok=True)\n        zarr.save_array(str(seg_path), np.asarray(tracks.segmentation))\n        metadata.related_objects = [\n            {\n                \"path\": \"../segmentation\",\n                \"type\": \"labels\",\n                \"label_prop\": NodeAttr.SEG_ID.value,\n            }\n        ]\n\n    # Save the graph in a 'tracks' folder\n    tracks_path = directory / \"tracks\"\n    tracks_path.mkdir(exist_ok=True)\n    geff.write_nx(\n        graph=graph,\n        store=tracks_path,\n        metadata=metadata,\n        axis_names=axis_names,\n        axis_types=axis_types,\n    )\n</code></pre>"},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.export_to_geff(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.export_to_geff(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.export_to_geff(overwrite)","title":"<code>overwrite</code>","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.split_position_attr","title":"split_position_attr","text":"<pre><code>split_position_attr(tracks: Tracks) -&gt; nx.DiGraph\n</code></pre> <p>Spread the spatial coordinates to separate node attrs in order to export to geff format.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>tracks object holding the graph to be converted.</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>nx.DiGraph with a separate positional attribute for each coordinate.</p> Source code in <code>src/funtracks/import_export/export_to_geff.py</code> <pre><code>def split_position_attr(tracks: Tracks) -&gt; nx.DiGraph:\n    \"\"\"Spread the spatial coordinates to separate node attrs in order to export to geff\n    format.\n\n    Args:\n        tracks (funtracks.data_model.Tracks): tracks object holding the graph to be\n          converted.\n\n    Returns:\n        nx.DiGraph with a separate positional attribute for each coordinate.\n\n    \"\"\"\n    new_graph = tracks.graph.copy()\n\n    for _, attrs in new_graph.nodes(data=True):\n        pos = attrs.pop(tracks.pos_attr)\n\n        if len(pos) == 2:\n            attrs[\"y\"] = pos[0]\n            attrs[\"x\"] = pos[1]\n        elif len(pos) == 3:\n            attrs[\"z\"] = pos[0]\n            attrs[\"y\"] = pos[1]\n            attrs[\"x\"] = pos[2]\n\n    return new_graph\n</code></pre>"},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.split_position_attr(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/","title":"import_from_geff","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff","title":"funtracks.import_export.import_from_geff","text":"<p>Functions:</p> Name Description <code>import_from_geff</code> <p>Load Tracks from a geff directory. Takes a name_map to map graph attributes</p> <code>relabel_seg_id_to_node_id</code> <p>Relabel the segmentation from seg_id to unique node id.</p> <code>validate_graph_seg_match</code> <p>Validate if the given geff matches the provided segmentation data. Raises a value</p>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff","title":"import_from_geff","text":"<pre><code>import_from_geff(directory: Path, name_map: dict[str, str], segmentation_path: Path | None = None, scale: list[float] | None = None, extra_features: dict[str, bool] | None = None)\n</code></pre> <p>Load Tracks from a geff directory. Takes a name_map to map graph attributes (spatial dimensions and optional track and lineage ids) to tracks attributes. Optionally takes a path to segmentation data, and verifies if the segmentation data matches with the graph data. If a scaling tuple is provided, it will be used to scale the spatial coordinates on the graph (world coordinates) to pixel coordinates when checking if segmentation data matches the graph data. If no scale is provided, the geff metadata will be queried for a scale, if it is not present, no scaling will be applied. Optional extra features, present as node properties in the geff, can be included by providing a dictionary with keys as the feature names and values as booleans indicating whether to they should be recomputed (currently only supported for the 'area' feature), or loaded as static node attributes.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>path to the geff tracks data or its parent folder.</p> required <code>dict[str, str]</code> <p>dictionary mapping required fields to node properties. Should include:     time,     (z),     y,     x,     (seg_id), if a segmentation is provided     (tracklet_id), optional, if it is a solution     (lineage_id), optional, if it is a solution</p> required <code>Path | None = None</code> <p>path to segmentation data.</p> <code>None</code> <code>list[float]</code> <p>scaling information (pixel to world coordinates).</p> <code>None</code> <p>bool] | None=None): optional features to include in the Tracks object. The keys are the feature names, and the boolean value indicates whether to recompute the feature (area) or load it as a static node attribute.</p> required <p>Returns:</p> Type Description <p>Tracks based on the geff graph and segmentation, if provided.</p> Source code in <code>src/funtracks/import_export/import_from_geff.py</code> <pre><code>def import_from_geff(\n    directory: Path,\n    name_map: dict[str, str],\n    segmentation_path: Path | None = None,\n    scale: list[float] | None = None,\n    extra_features: dict[str, bool] | None = None,\n):\n    \"\"\"Load Tracks from a geff directory. Takes a name_map to map graph attributes\n    (spatial dimensions and optional track and lineage ids) to tracks attributes.\n    Optionally takes a path to segmentation data, and verifies if the segmentation data\n    matches with the graph data. If a scaling tuple is provided, it will be used to scale\n    the spatial coordinates on the graph (world coordinates) to pixel coordinates when\n    checking if segmentation data matches the graph data. If no scale is provided, the\n    geff metadata will be queried for a scale, if it is not present, no scaling will be\n    applied. Optional extra features, present as node properties in the geff, can be\n    included by providing a dictionary with keys as the feature names and values as\n    booleans indicating whether to they should be recomputed (currently only supported for\n    the 'area' feature), or loaded as static node attributes.\n\n    Args:\n        directory (Path): path to the geff tracks data or its parent folder.\n        name_map (dict[str,str]): dictionary mapping required fields to node properties.\n            Should include:\n                time,\n                (z),\n                y,\n                x,\n                (seg_id), if a segmentation is provided\n                (tracklet_id), optional, if it is a solution\n                (lineage_id), optional, if it is a solution\n        segmentation_path (Path | None = None): path to segmentation data.\n        scale (list[float]): scaling information (pixel to world coordinates).\n        extra_features (dict[str: bool] | None=None): optional features to include in the\n            Tracks object. The keys are the feature names, and the boolean value indicates\n            whether to recompute the feature (area) or load it as a static node attribute.\n\n    Returns:\n        Tracks based on the geff graph and segmentation, if provided.\n    \"\"\"\n\n    group = zarr.open_group(directory, mode=\"r\")\n    metadata = dict(group.attrs)\n    selected_attrs = []\n    segmentation = None\n\n    # Check that the spatiotemporal key mapping does not contain None or duplicate values.\n    # It is allowed to not include z, but it is not allowed to include z with a None or\n    # duplicate value.\n    spatio_temporal_keys = [NodeAttr.TIME.value, \"z\", \"y\", \"x\"]\n    spatio_temporal_map = {\n        key: name_map[key] for key in spatio_temporal_keys if key in name_map\n    }\n    if any(v is None for v in spatio_temporal_map.values()):\n        raise ValueError(\n            \"The name_map cannot contain None values. Please provide a valid mapping \"\n            \"for all required fields.\"\n        )\n    if len(set(spatio_temporal_map.values())) != len(spatio_temporal_map.values()):\n        raise ValueError(\n            \"The name_map cannot contain duplicate values. Please provide a unique \"\n            \"mapping for each required field.\"\n        )\n\n    # Extract the time and position attributes from the name_map, containing and optional\n    # z coordinate.\n    time_attr = name_map[NodeAttr.TIME.value]\n    selected_attrs.append(name_map[NodeAttr.TIME.value])\n    position_attr = [name_map[k] for k in (\"z\", \"y\", \"x\") if k in name_map]\n    selected_attrs.extend(position_attr)\n    ndims = len(position_attr) + 1\n\n    # if no scale is provided, load from metadata, if available.\n    if scale is None:\n        affine = metadata.get(\"affine\", {}).get(\"matrix\", None)\n        if affine is not None:\n            affine = Affine(matrix=affine)\n            linear = affine.linear_matrix\n            scale = list(np.diag(linear))\n        else:\n            scale = list([1.0] * ndims)\n\n    # Check if a track_id was provided, and if it is valid add it to list of selected\n    # attributes. If it is not provided, it will be computed again.\n    if name_map.get(NodeAttr.TRACK_ID.value) is not None:\n        # if track id is present, it is a solution graph\n        valid_track_ids, errors = validate_tracklets(\n            node_ids=group[\"nodes\"][\"ids\"][:],\n            edge_ids=group[\"edges\"][\"ids\"][:],\n            tracklet_ids=group[\"nodes\"][\"props\"][name_map[NodeAttr.TRACK_ID.value]][\n                \"values\"\n            ][:],\n        )\n        if valid_track_ids:\n            selected_attrs.append(NodeAttr.TRACK_ID.value)\n    recompute_track_ids = NodeAttr.TRACK_ID.value not in selected_attrs\n\n    # Check if a lineage_id was provided, and if it is valid add it to list of selected\n    # attributes. If it is not provided, it will be a static feature (for now).\n    if name_map.get(\"lineage_id\") is not None:\n        valid_lineages, errors = validate_lineages(\n            node_ids=group[\"nodes\"][\"ids\"],\n            edge_ids=group[\"edges\"][\"ids\"],\n            lineage_ids=group[\"nodes\"][\"props\"][name_map[\"lineage_id\"]][\"values\"],\n        )\n        if valid_lineages:\n            selected_attrs.append(name_map[\"lineage_id\"])\n\n    # Try to load the segmentation data, if it was provided.\n    if segmentation_path is not None:\n        segmentation = magic_imread(\n            segmentation_path, use_dask=True\n        )  # change to in memory later\n\n        relabel = validate_graph_seg_match(\n            directory, segmentation, name_map, scale, position_attr\n        )\n\n        # If the provided segmentation has seg ids that are not identical to node ids,\n        # relabel it now.\n        if relabel:\n            times = group[\"nodes\"][\"props\"][name_map[NodeAttr.TIME.value]][\"values\"][:]\n            ids = group[\"nodes\"][\"ids\"][:]\n            seg_ids = group[\"nodes\"][\"props\"][name_map[NodeAttr.SEG_ID.value]][\"values\"][\n                :\n            ]\n\n            if not len(times) == len(ids) == len(seg_ids):\n                raise ValueError(\n                    \"Encountered missing values in the seg_id to node id conversion.\"\n                )\n            segmentation = relabel_seg_id_to_node_id(times, ids, seg_ids, segmentation)\n\n    # Add optional extra features.\n    if extra_features is None:\n        extra_features = {}\n    selected_attrs.extend(extra_features.keys())\n\n    # All pre-checks have passed, load the graph now.\n    graph, _ = geff.read_nx(directory, node_props=selected_attrs)\n\n    # Relabel track_id attr to NodeAttr.TRACK_ID.value (unless we should recompute)\n    if name_map.get(NodeAttr.TRACK_ID.value) is not None and not recompute_track_ids:\n        for _, data in graph.nodes(data=True):\n            try:\n                data[NodeAttr.TRACK_ID.value] = data.pop(\n                    name_map[NodeAttr.TRACK_ID.value]\n                )\n            except KeyError:\n                recompute_track_ids = True\n                break\n\n    # Put segmentation data in memory now.\n    if segmentation is not None and isinstance(segmentation, da.Array):\n        segmentation = segmentation.compute()\n\n    # Create the tracks.\n    tracks = SolutionTracks(\n        graph=graph,\n        segmentation=segmentation,\n        pos_attr=position_attr,\n        time_attr=time_attr,\n        ndim=ndims,\n        scale=scale,\n        recompute_track_ids=recompute_track_ids,\n    )\n    # compute the 'area' attribute if needed\n    if tracks.segmentation is not None and extra_features.get(\"area\"):\n        nodes = tracks.graph.nodes\n        times = tracks.get_times(nodes)\n        computed_attrs = tracks._compute_node_attrs(nodes, times)\n        areas = computed_attrs[NodeAttr.AREA.value]\n        tracks._set_nodes_attr(nodes, NodeAttr.AREA.value, areas)\n\n    return tracks\n</code></pre>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff(name_map)","title":"<code>name_map</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff(segmentation_path)","title":"<code>segmentation_path</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff(scale)","title":"<code>scale</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff(extra_features (dict[str)","title":"<code>extra_features (dict[str</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.relabel_seg_id_to_node_id","title":"relabel_seg_id_to_node_id","text":"<pre><code>relabel_seg_id_to_node_id(times: ArrayLike, ids: ArrayLike, seg_ids: ArrayLike, segmentation: Array) -&gt; np.ndarray\n</code></pre> <p>Relabel the segmentation from seg_id to unique node id. Args:     times (ArrayLike): array of time points, one per node     ids (ArrayLike): array of node ids     seg_ids (ArrayLike): array of segmentation ids, one per node     segmentation (da.array): A dask array where segmentation label values match the       \"seg_id\" values.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A numpy array of dtype uint64, similar to the input segmentation where each segmentation now has a unique label across time that corresponds to the ID of each node.</p> Source code in <code>src/funtracks/import_export/import_from_geff.py</code> <pre><code>def relabel_seg_id_to_node_id(\n    times: ArrayLike, ids: ArrayLike, seg_ids: ArrayLike, segmentation: da.Array\n) -&gt; np.ndarray:\n    \"\"\"Relabel the segmentation from seg_id to unique node id.\n    Args:\n        times (ArrayLike): array of time points, one per node\n        ids (ArrayLike): array of node ids\n        seg_ids (ArrayLike): array of segmentation ids, one per node\n        segmentation (da.array): A dask array where segmentation label values match the\n          \"seg_id\" values.\n\n    Returns:\n        np.ndarray: A numpy array of dtype uint64, similar to the input segmentation\n            where each segmentation now has a unique label across time that corresponds\n            to the ID of each node.\n    \"\"\"\n\n    new_segmentation = np.zeros(segmentation.shape, dtype=np.uint64)\n    for i, node in enumerate(ids):\n        mask = segmentation[times[i]].compute() == seg_ids[i]\n        new_segmentation[times[i], mask] = node\n\n    return new_segmentation\n</code></pre>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match","title":"validate_graph_seg_match","text":"<pre><code>validate_graph_seg_match(directory: Path, segmentation: ArrayLike, name_map: dict[str, str], scale: list[float], position_attr: list[str]) -&gt; bool\n</code></pre> <p>Validate if the given geff matches the provided segmentation data. Raises a value error if no valid seg ids are provided, if the metadata axes do not match the segmentation shape, or if the seg_id value of the last node does not match the pixel value at the (scaled) node coordinates. Returns a boolean indicating whether relabeling of the segmentation to match it to node id values is required.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>path to the geff tracks data or its parent folder.</p> required <code>dict[str, str]</code> <p>dictionary mapping required fields to node properties.</p> required <code>ArrayLike</code> <p>segmentation data.</p> required <code>list[float]</code> <p>scaling information (pixel to world coordinates).</p> required <code>list[str]</code> <p>position keys in the geff tracks data</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if relabeling from seg_id to node_id is required.</p> Source code in <code>src/funtracks/import_export/import_from_geff.py</code> <pre><code>def validate_graph_seg_match(\n    directory: Path,\n    segmentation: ArrayLike,\n    name_map: dict[str, str],\n    scale: list[float],\n    position_attr: list[str],\n) -&gt; bool:\n    \"\"\"Validate if the given geff matches the provided segmentation data. Raises a value\n    error if no valid seg ids are provided, if the metadata axes do not match the\n    segmentation shape, or if the seg_id value of the last node does not match the pixel\n    value at the (scaled) node coordinates. Returns a boolean indicating whether\n    relabeling of the segmentation to match it to node id values is required.\n\n    Args:\n        directory (Path): path to the geff tracks data or its parent folder.\n        name_map (dict[str,str]): dictionary mapping required fields to node properties.\n        segmentation (ArrayLike): segmentation data.\n        scale (list[float]): scaling information (pixel to world coordinates).\n        position_attr (list[str]): position keys in the geff tracks data\n\n    Returns:\n        bool: True if relabeling from seg_id to node_id is required.\n    \"\"\"\n\n    group = zarr.open_group(directory, mode=\"r\")\n    # check if the axes information in the metadata matches the segmentation\n    # dimensions\n    axes_match, errors = axes_match_seg_dims(directory, segmentation)\n    if not axes_match:\n        error_msg = \"Axes in the geff do not match segmentation:\\n\" + \"\\n\".join(\n            f\"- {e}\" for e in errors\n        )\n        raise ValueError(error_msg)\n\n    # Check if valid seg_ids are provided\n    if name_map.get(NodeAttr.SEG_ID.value) is not None:\n        seg_ids_valid, errors = has_valid_seg_id(\n            directory, name_map[NodeAttr.SEG_ID.value]\n        )\n        if not seg_ids_valid:\n            error_msg = \"Error in validating the segmentation ids:\\n\" + \"\\n\".join(\n                f\"- {e}\" for e in errors\n            )\n            raise ValueError(error_msg)\n        seg_id = int(\n            group[\"nodes\"][\"props\"][name_map[NodeAttr.SEG_ID.value]][\"values\"][-1]\n        )\n    else:\n        # assign the node id as seg_id instead and check in the next step if this is\n        #  valid.\n        seg_id = int(group[\"nodes\"][\"ids\"][-1])\n\n    # Get the coordinates for the last node.\n    t = group[\"nodes\"][\"props\"][name_map[NodeAttr.TIME.value]][\"values\"][-1]\n    z = (\n        group[\"nodes\"][\"props\"][name_map[\"z\"]][\"values\"][-1]\n        if len(position_attr) == 3\n        else None\n    )\n    y = group[\"nodes\"][\"props\"][name_map[\"y\"]][\"values\"][-1]\n    x = group[\"nodes\"][\"props\"][name_map[\"x\"]][\"values\"][-1]\n\n    coord = []\n    coord.append(t)\n    if z is not None:\n        coord.append(z)\n    coord.append(y)\n    coord.append(x)\n\n    # Check if the segmentation pixel value at the coordinates of the last node\n    # matches the seg id. Since the scale factor was used to convert from pixels to\n    # world coordinates, we need to invert this scale factor to get the pixel\n    # coordinates.\n    seg_id_at_coord, errors = has_seg_ids_at_coords(\n        segmentation, [coord], [seg_id], tuple(1 / s for s in scale)\n    )\n    if not seg_id_at_coord:\n        error_msg = \"Error testing seg id:\\n\" + \"\\n\".join(f\"- {e}\" for e in errors)\n        raise ValueError(error_msg)\n\n    return group[\"nodes\"][\"ids\"][-1] != seg_id\n</code></pre>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match(name_map)","title":"<code>name_map</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match(segmentation)","title":"<code>segmentation</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match(scale)","title":"<code>scale</code>","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match(position_attr)","title":"<code>position_attr</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/","title":"internal_format","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format","title":"funtracks.import_export.internal_format","text":"<p>Functions:</p> Name Description <code>delete_tracks</code> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <code>load_tracks</code> <p>Load a Tracks object from the given directory. Looks for files</p> <code>save_tracks</code> <p>Save the tracks to the given directory.</p>"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.delete_tracks","title":"delete_tracks","text":"<pre><code>delete_tracks(directory: Path | str)\n</code></pre> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>Path to a directory containing tracks</p> required Source code in <code>src/funtracks/import_export/internal_format.py</code> <pre><code>def delete_tracks(directory: Path | str):\n    \"\"\"Delete the tracks in the given directory. Also deletes the directory.\n\n    Args:\n        directory (Path | str): Path to a directory containing tracks\n    \"\"\"\n    if not isinstance(directory, Path):\n        directory = Path(directory)\n    (directory / GRAPH_FILE).unlink()\n    (directory / SEG_FILE).unlink(missing_ok=True)\n    (directory / ATTRS_FILE).unlink()\n    directory.rmdir()\n</code></pre>"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.delete_tracks(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.load_tracks","title":"load_tracks","text":"<pre><code>load_tracks(directory: Path, seg_required: bool = False, solution: bool = False) -&gt; Tracks | SolutionTracks\n</code></pre> <p>Load a Tracks object from the given directory. Looks for files in the format generated by Tracks.save.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The directory containing tracks to load</p> required <code>bool</code> <p>If true, raises a FileNotFoundError if the segmentation file is not present in the directory. Defaults to False.</p> <code>False</code> <code>bool</code> <p>If true, returns a SolutionTracks object, otherwise reutrns a normal Tracks object. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Tracks</code> <code>Tracks | SolutionTracks</code> <p>A tracks object loaded from the given directory</p> Source code in <code>src/funtracks/import_export/internal_format.py</code> <pre><code>def load_tracks(\n    directory: Path, seg_required: bool = False, solution: bool = False\n) -&gt; Tracks | SolutionTracks:\n    \"\"\"Load a Tracks object from the given directory. Looks for files\n    in the format generated by Tracks.save.\n\n    Args:\n        directory (Path): The directory containing tracks to load\n        seg_required (bool, optional): If true, raises a FileNotFoundError if the\n            segmentation file is not present in the directory. Defaults to False.\n        solution (bool, optional): If true, returns a SolutionTracks object, otherwise\n            reutrns a normal Tracks object. Defaults to False.\n\n    Returns:\n        Tracks: A tracks object loaded from the given directory\n    \"\"\"\n    graph_file = directory / GRAPH_FILE\n    graph = _load_graph(graph_file)\n\n    seg_file = directory / SEG_FILE\n    seg = _load_seg(seg_file, seg_required=seg_required)\n\n    attrs_file = directory / ATTRS_FILE\n    attrs = _load_attrs(attrs_file)\n\n    if solution:\n        return SolutionTracks(graph, seg, **attrs)\n    else:\n        return Tracks(graph, seg, **attrs)\n</code></pre>"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.load_tracks(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.load_tracks(seg_required)","title":"<code>seg_required</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.load_tracks(solution)","title":"<code>solution</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.save_tracks","title":"save_tracks","text":"<pre><code>save_tracks(tracks: Tracks, directory: Path)\n</code></pre> <p>Save the tracks to the given directory. Currently, saves the graph as a json file in networkx node link data format, saves the segmentation as a numpy npz file, and saves the time and position attributes and scale information in an attributes json file. Will make the directory if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>Tracks</code> <p>the tracks to save</p> required <code>Path</code> <p>The directory to save the tracks in.</p> required Source code in <code>src/funtracks/import_export/internal_format.py</code> <pre><code>def save_tracks(tracks: Tracks, directory: Path):\n    \"\"\"Save the tracks to the given directory.\n    Currently, saves the graph as a json file in networkx node link data format,\n    saves the segmentation as a numpy npz file, and saves the time and position\n    attributes and scale information in an attributes json file.\n    Will make the directory if it doesn't exist.\n\n    Args:\n        tracks (Tracks): the tracks to save\n        directory (Path): The directory to save the tracks in.\n    \"\"\"\n    directory.mkdir(exist_ok=True, parents=True)\n    _save_graph(tracks, directory)\n    _save_seg(tracks, directory)\n    _save_attrs(tracks, directory)\n</code></pre>"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.save_tracks(tracks)","title":"<code>tracks</code>","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.save_tracks(directory)","title":"<code>directory</code>","text":""},{"location":"reference/funtracks/import_export/magic_imread/","title":"magic_imread","text":""},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread","title":"funtracks.import_export.magic_imread","text":"<p>Adapted implementation of napari.napari_builtins.io._read.magic_imread</p> <p>Functions:</p> Name Description <code>imread</code> <p>Read an image from a string file path using tifffile.imwrite.</p> <code>magic_imread</code> <p>Dispatch the appropriate reader given some files.</p> <code>read_zarr_dataset</code> <p>Read a zarr dataset, including an array or a group of arrays.</p>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.imread","title":"imread","text":"<pre><code>imread(filename: str) -&gt; np.ndarray\n</code></pre> <p>Read an image from a string file path using tifffile.imwrite.</p> Source code in <code>src/funtracks/import_export/magic_imread.py</code> <pre><code>def imread(filename: str) -&gt; np.ndarray:\n    \"\"\"Read an image from a string file path using tifffile.imwrite.\"\"\"\n    return tifffile.imread(filename)\n</code></pre>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.magic_imread","title":"magic_imread","text":"<pre><code>magic_imread(filenames: PathOrStr | list[PathOrStr], *, use_dask=None, stack=True) -&gt; ArrayLike | list[ArrayLike]\n</code></pre> <p>Dispatch the appropriate reader given some files.</p> Source code in <code>src/funtracks/import_export/magic_imread.py</code> <pre><code>def magic_imread(\n    filenames: PathOrStr | list[PathOrStr], *, use_dask=None, stack=True\n) -&gt; ArrayLike | list[ArrayLike]:\n    \"\"\"Dispatch the appropriate reader given some files.\"\"\"\n\n    _filenames: list[str] = (\n        [str(x) for x in filenames]\n        if isinstance(filenames, list | tuple)\n        else [str(filenames)]\n    )\n\n    if not _filenames:\n        raise ValueError(\"No files provided\")\n\n    filenames_expanded: list[str] = []\n    for filename in _filenames:\n        path = Path(filename)\n        if path.is_dir() and not _guess_zarr_path(path):\n            dir_contents = sorted(\n                glob(str(path / \"*.tif\")) + glob(str(path / \"*.tiff\")),\n                key=_alphanumeric_key,\n            )\n            dir_contents_files = [f for f in dir_contents if not Path(f).is_dir()]\n            filenames_expanded.extend(dir_contents_files)\n        else:\n            filenames_expanded.append(filename)\n\n    if not filenames_expanded:\n        raise ValueError(f\"No readable TIFF files found in {filenames}\")\n\n    if use_dask is None:\n        use_dask = len(filenames_expanded) &gt; 1\n\n    images: list[ArrayLike] = []\n    shape: tuple[int, ...] | None = None\n    dtype = None\n\n    for filename in filenames_expanded:\n        path = Path(filename)\n        if _guess_zarr_path(path):\n            image, zarr_shape = read_zarr_dataset(path)\n            if len(zarr_shape) == 1:\n                continue\n            if shape is None:\n                shape = zarr_shape\n        else:\n            if shape is None:\n                image = imread(filename)\n                shape = image.shape\n                dtype = image.dtype\n            if use_dask:\n                image = da.from_delayed(\n                    delayed(imread)(filename), shape=shape, dtype=dtype\n                )\n            elif len(images) &gt; 0:\n                image = imread(filename)\n        images.append(image)\n\n    if not images:\n        raise ValueError(\"No valid images loaded\")\n\n    if len(images) == 1:\n        return images[0]\n    elif stack:\n        if use_dask:\n            return da.stack(images)\n        else:\n            try:\n                return np.stack(images)\n            except ValueError as e:\n                raise ValueError(\n                    \"To stack multiple files with numpy, all input arrays must have the\"\n                    \" same shape. Set `use_dask=True` to allow stacking with different \"\n                    \"shapes.\"\n                ) from e\n    else:\n        return images\n</code></pre>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.read_zarr_dataset","title":"read_zarr_dataset","text":"<pre><code>read_zarr_dataset(path: Path) -&gt; tuple[ArrayLike | list[ArrayLike], tuple[int]]\n</code></pre> <p>Read a zarr dataset, including an array or a group of arrays.</p> Source code in <code>src/funtracks/import_export/magic_imread.py</code> <pre><code>def read_zarr_dataset(path: Path) -&gt; tuple[ArrayLike | list[ArrayLike], tuple[int]]:\n    \"\"\"Read a zarr dataset, including an array or a group of arrays.\"\"\"\n    if (path / \".zarray\").exists():\n        image = da.from_zarr(path)\n        shape = image.shape\n    elif (path / \"zarr.json\").exists():\n        data = zarr.open(store=path)\n        if isinstance(data, zarr.Array):\n            image = da.from_zarr(data)\n            shape = image.shape\n        else:\n            raise ValueError(f\"Not a valid zarr dataset: {path}\")\n    else:\n        raise ValueError(f\"Not a valid zarr dataset: {path}\")\n    return image, shape\n</code></pre>"}]}