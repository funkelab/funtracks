{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Funtracks","text":"<p>A data model for cell tracking with actions, undo history, persistence, and more!</p> <p>Designed for use with the finn tracks viewer and motile tracker. Provides a data model for programmatic editing of tracks that can be used by a UI like finn or by a machine agent for active learning.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install funtracks</code></p> <p>Or use pixi!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Features already included in funtracks: - fully undo-able action history</p> <p>Features that will be included in funtracks: - both in-memory and out-of-memory tracks   - in-memory using networkx (slower, pure python) or spatial_graph (faster, compiled C) data structures   - out-of-memory using zarr for segmentations and SQLite/PostGreSQL for graphs - functions to import from and export to common file structures (csv, segmentation relabeled by track id) - generic features with the option to automatically update features on tracks editing actions</p>"},{"location":"architecture/","title":"Funtracks Feature Architecture Design","text":"<p>This document describes the internal architecture of funtracks Features for developers who want to understand or extend the system.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>Funtracks has a feature computation system that manages attributes (features) from tracking graphs with optional segmentation data. The architecture separates:</p> <ol> <li>Feature metadata (what features exist and their properties) - <code>Feature</code> class</li> <li>Feature computation (how to calculate feature values) - <code>GraphAnnotator</code> class</li> <li>Feature storage (where feature values live on the graph) - attributes on the graph nodes/edges</li> <li>Feature lifecycle (when to compute, activate, or update features) - computation called by <code>Tracks</code>, updates triggered by <code>BasicActions</code></li> </ol>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-feature-typeddict","title":"1. Feature (TypedDict)","text":"<p>A <code>Feature</code> is a TypedDict that stores metadata about a graph feature.</p> Show API documentation <p>               Bases: <code>TypedDict</code></p> <p>TypedDict for storing metadata associated with a graph feature.</p> <p>Use factory functions like Time(), Position(), Area() etc. to create features with standard defaults.</p> <p>The key is stored separately in the FeatureDict mapping (not in the Feature itself).</p> <p>Attributes:</p> Name Type Description <code>feature_type</code> <code>Literal['node', 'edge']</code> <p>Specifies which graph elements the feature applies to.</p> <code>value_type</code> <code>Literal['int', 'float', 'str', 'bool']</code> <p>The data type of the feature values.</p> <code>num_values</code> <code>int</code> <p>The number of values expected for this feature.</p> <code>display_name</code> <code>str | Sequence[str] | None</code> <p>The name to use to display the feature.</p> <code>required</code> <code>bool</code> <p>If True, all nodes/edges in the graph are required to have this feature.</p> <code>default_value</code> <code>Any</code> <p>If required is False, this value is returned whenever the feature value is missing on the graph.</p>"},{"location":"architecture/#2-featuredict","title":"2. FeatureDict","text":"<p>A <code>FeatureDict</code> is a dictionary (<code>dict[str, Feature]</code>) with special tracking for important feature keys:</p> Show API documentation <p>               Bases: <code>dict[str, Feature]</code></p> <p>A dictionary mapping keys to Features, with special tracking for time/position.</p> <p>Inherits from dict[str, Feature], so can be used directly as a dictionary. Provides convenient access to time and position features through properties.</p> <p>Attributes:</p> Name Type Description <code>time_key</code> <code>str</code> <p>The key used for the time feature</p> <code>position_key</code> <code>str | list[str] | None</code> <p>The key(s) used for position feature(s)</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>dict[str, Feature]</code> <p>Mapping from feature keys to Features</p> required <code>time_key</code> <code>str</code> <p>The key for the time feature (must be in features)</p> required <code>position_key</code> <code>str | list[str] | None</code> <p>The key(s) for position feature(s)</p> required <code>tracklet_key</code> <code>str | None</code> <p>The key for the tracklet feature</p> required"},{"location":"architecture/#funtracks.features.FeatureDict.edge_features","title":"edge_features","text":"<pre><code>edge_features: dict[str, Feature]\n</code></pre> <p>A dict of all edge features</p>"},{"location":"architecture/#funtracks.features.FeatureDict.node_features","title":"node_features","text":"<pre><code>node_features: dict[str, Feature]\n</code></pre> <p>A dict of all node features</p>"},{"location":"architecture/#funtracks.features.FeatureDict.dump_json","title":"dump_json","text":"<pre><code>dump_json() -&gt; dict\n</code></pre> <p>Dump this FeatureDict to a json compatible dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A map from the key \"FeatureDict\" containing features, time_key, position_key, and tracklet_key</p>"},{"location":"architecture/#funtracks.features.FeatureDict.from_json","title":"from_json","text":"<pre><code>from_json(json_dict: dict) -&gt; FeatureDict\n</code></pre> <p>Generate a FeatureDict from a json dict such as one generated by dump_json</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>A dictionary with the key \"FeatureDict\" containing features, time_key, position_key, and tracklet_key</p> required <p>Returns:</p> Name Type Description <code>FeatureDict</code> <code>FeatureDict</code> <p>A FeatureDict object containing the features from the dictionary</p>"},{"location":"architecture/#funtracks.features.FeatureDict.register_position_feature","title":"register_position_feature","text":"<pre><code>register_position_feature(\n    key: str, feature: Feature\n) -&gt; None\n</code></pre> <p>Register the position feature and set the position_key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to use for the position feature</p> required <code>feature</code> <code>Feature</code> <p>The Feature to register</p> required"},{"location":"architecture/#funtracks.features.FeatureDict.register_tracklet_feature","title":"register_tracklet_feature","text":"<pre><code>register_tracklet_feature(\n    key: str, feature: Feature\n) -&gt; None\n</code></pre> <p>Register the tracklet/track_id feature and set the tracklet_key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to use for the tracklet feature</p> required <code>feature</code> <code>Feature</code> <p>The Feature to register</p> required"},{"location":"architecture/#3-graphannotator-base-class","title":"3. GraphAnnotator (Base Class)","text":"<p>An abstract base class for components that compute and update features on a graph.</p> Show API documentation <p>A base class for adding and updating graph features.</p> <p>This class holds a set of features that it is responsible for. The annotator will compute these features and add them to the Tracks initially, and update them when necessary. The set of features will all be computed and updated together, although individual ones can be removed for efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to manage features for.</p> required <code>features</code> <code>dict[str, Feature]</code> <p>A dict mapping keys to features that this annotator is capable of computing and updating.</p> required <p>Attributes:</p> Name Type Description <code>all_features</code> <code>dict[str, tuple[Feature, bool]]</code> <p>Maps feature keys to (feature, is_included) tuples. Tracks both what can be computed and what is currently being computed. Defaults to computing nothing.</p>"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.features","title":"features","text":"<pre><code>features: dict[str, Feature]\n</code></pre> <p>The dict of features that this annotator currently manages.</p> <p>Filtered from all_features based on inclusion flags.</p>"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.activate_features","title":"activate_features","text":"<pre><code>activate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Activate computation of the given features in the annotation process.</p> <p>Filters the list to only features this annotator owns, ignoring others.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to activate. Only keys in all_features are activated.</p> required"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.can_annotate","title":"can_annotate","text":"<pre><code>can_annotate(tracks: Tracks) -&gt; bool\n</code></pre> <p>Check if this annotator can annotate the given tracks.</p> <p>Subclasses should override this method to specify their requirements (e.g., segmentation, SolutionTracks, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to check compatibility with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the annotator can annotate these tracks, False otherwise</p>"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute a set of features and add them to the tracks.</p> <p>This involves both updating the node/edge attributes on the tracks.graph and adding the features to the FeatureDict, if necessary. This is distinct from <code>update</code> to allow more efficient bulk computation of features.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features. Any provided keys not in the currently active set are ignored.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.deactivate_features","title":"deactivate_features","text":"<pre><code>deactivate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Deactivate computation of the given features in the annotation process.</p> <p>Filters the list to only features this annotator owns, ignoring others.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to deactivate. Only keys in all_features are deactivated.</p> required"},{"location":"architecture/#funtracks.annotators.GraphAnnotator.update","title":"update","text":"<pre><code>update(action: BasicAction) -&gt; None\n</code></pre> <p>Update a set of features based on the given action.</p> <p>This involves both updating the node or edge attributes on the tracks.graph and adding the features to the FeatureDict, if necessary. This is distinct from <code>compute</code> to allow more efficient computation of features for single elements.</p> <p>The action contains all necessary information about which elements to update (e.g., AddNode.node, AddEdge.edge, UpdateNodeSeg.node).</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"architecture/#4-graphannotator-implementations","title":"4. GraphAnnotator Implementations","text":"Annotator Purpose Requirements Features Computed API Reference RegionpropsAnnotator Extracts node features from segmentation using scikit-image's <code>regionprops</code> <code>segmentation</code> must not be <code>None</code> <code>pos</code>, <code>area</code>, <code>ellipse_axis_radii</code>, <code>circularity</code>, <code>perimeter</code> \ud83d\udcda API EdgeAnnotator Computes edge features based on segmentation overlap between consecutive time frames <code>segmentation</code> must not be <code>None</code> <code>iou</code> (Intersection over Union) \ud83d\udcda API TrackAnnotator Computes tracklet and lineage IDs for SolutionTracks Must be used with <code>SolutionTracks</code> (binary tree structure) <code>tracklet_id</code>, <code>lineage_id</code> \ud83d\udcda API"},{"location":"architecture/#5-annotatorregistry","title":"5. AnnotatorRegistry","text":"<p>A registry that manages multiple <code>GraphAnnotator</code> instances with a unified interface. Extends <code>list[GraphAnnotator]</code>.</p> Show API documentation <p>               Bases: <code>list[GraphAnnotator]</code></p> <p>A list of annotators with coordinated operations.</p> <p>Inherits from list[GraphAnnotator], so can be used directly as a list. Provides coordinated compute/update/enable/disable operations across all annotators.</p> Example <p>annotators = AnnotatorRegistry([     RegionpropsAnnotator(tracks, pos_key=\"centroid\"),     EdgeAnnotator(tracks),     TrackAnnotator(tracks, tracklet_key=\"track_id\"), ])</p> <p>Initialize with a list of annotators.</p> <p>Parameters:</p> Name Type Description Default <code>annotators</code> <code>list[GraphAnnotator]</code> <p>List of instantiated annotator objects</p> required"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry--can-use-as-a-list","title":"Can use as a list","text":"<p>annotators.append(MyCustomAnnotator(tracks))</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry--coordinated-operations","title":"Coordinated operations","text":"<p>annotators.activate_features([\"area\", \"iou\"]) annotators.compute()</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.all_features","title":"all_features","text":"<pre><code>all_features: dict[str, tuple[Feature, bool]]\n</code></pre> <p>Dynamically aggregate all_features from all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, tuple[Feature, bool]]</code> <p>Dictionary mapping feature keys to (Feature, is_enabled) tuples</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.features","title":"features","text":"<pre><code>features: dict[str, Feature]\n</code></pre> <p>Get all currently active features from all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions (only active features)</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.activate_features","title":"activate_features","text":"<pre><code>activate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Activate features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to activate</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature keys are not available</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features.</p> <code>None</code>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.deactivate_features","title":"deactivate_features","text":"<pre><code>deactivate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Deactivate features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to deactivate</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature keys are not available</p>"},{"location":"architecture/#funtracks.annotators.AnnotatorRegistry.update","title":"update","text":"<pre><code>update(action: BasicAction) -&gt; None\n</code></pre> <p>Update features across all annotators based on the action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required"},{"location":"architecture/#6-tracks","title":"6. Tracks","text":"<p>The main class representing a set of tracks: a graph + optional segmentation + features.</p> Show API documentation <p>A set of tracks consisting of a graph and an optional segmentation.</p> <p>The graph nodes represent detections and must have a time attribute and position attribute. Edges in the graph represent links across time.</p> <p>Attributes:</p> Name Type Description <code>graph</code> <code>DiGraph</code> <p>A graph with nodes representing detections and and edges representing links across time.</p> <code>segmentation</code> <code>ndarray | None</code> <p>An optional segmentation that accompanies the tracking graph. If a segmentation is provided, the node ids in the graph must match the segmentation labels.</p> <code>features</code> <code>FeatureDict</code> <p>Dictionary of features tracked on graph nodes/edges.</p> <code>annotators</code> <code>AnnotatorRegistry</code> <p>List of annotators that compute features.</p> <code>scale</code> <code>list[float] | None</code> <p>How much to scale each dimension by, including time.</p> <code>ndim</code> <code>int</code> <p>Number of dimensions (3 for 2D+time, 4 for 3D+time).</p> <p>Initialize a Tracks object.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>NetworkX directed graph with nodes as detections and edges as links.</p> required <code>segmentation</code> <code>ndarray | None</code> <p>Optional segmentation array where labels match node IDs. Required for computing region properties (area, etc.).</p> <code>None</code> <code>time_attr</code> <code>str | None</code> <p>Graph attribute name for time. Defaults to \"time\" if None.</p> <code>None</code> <code>pos_attr</code> <code>str | tuple[str, ...] | list[str] | None</code> <p>Graph attribute name(s) for position. Can be: - Single string for one attribute containing position array - List/tuple of strings for multi-axis (one attribute per axis) Defaults to \"pos\" if None.</p> <code>None</code> <code>tracklet_attr</code> <code>str | None</code> <p>Graph attribute name for tracklet/track IDs. Defaults to \"track_id\" if None.</p> <code>None</code> <code>scale</code> <code>list[float] | None</code> <p>Scaling factors for each dimension (including time). If None, all dimensions scaled by 1.0.</p> <code>None</code> <code>ndim</code> <code>int | None</code> <p>Number of dimensions (3 for 2D+time, 4 for 3D+time). If None, inferred from segmentation or scale.</p> <code>None</code> <code>features</code> <code>FeatureDict | None</code> <p>Pre-built FeatureDict with feature definitions. If provided, time_attr/pos_attr/tracklet_attr are ignored. Assumes that all features in the dict already exist on the graph (will be activated but not recomputed). If None, core computed features (pos, area, track_id) are auto-detected by checking if they exist on the graph.</p> <code>None</code>"},{"location":"architecture/#funtracks.data_model.Tracks.delete","title":"delete","text":"<pre><code>delete(directory: Path)\n</code></pre> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>Directory containing tracks to be deleted</p> required"},{"location":"architecture/#funtracks.data_model.Tracks.disable_features","title":"disable_features","text":"<pre><code>disable_features(feature_keys: list[str]) -&gt; None\n</code></pre> <p>Disable multiple features from computation.</p> <p>Removes features from annotators and FeatureDict.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str]</code> <p>List of feature keys to disable</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature is not available (raised by annotators)</p>"},{"location":"architecture/#funtracks.data_model.Tracks.enable_features","title":"enable_features","text":"<pre><code>enable_features(feature_keys: list[str]) -&gt; None\n</code></pre> <p>Enable multiple features for computation efficiently.</p> <p>Adds features to annotators and FeatureDict, then computes their values.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str]</code> <p>List of feature keys to enable</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature is not available (raised by annotators)</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_area","title":"get_area","text":"<pre><code>get_area(node: Node) -&gt; int | None\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>.. deprecated:: 1.0     <code>get_area</code> will be removed in funtracks v2.0.     Use <code>get_node_attr(node, \"area\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int | None</code> <p>The area/volume of the node</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_areas","title":"get_areas","text":"<pre><code>get_areas(nodes: Iterable[Node]) -&gt; Sequence[int | None]\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>.. deprecated:: 1.0     <code>get_areas</code> will be removed in funtracks v2.0.     Use <code>get_nodes_attr(nodes, \"area\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Sequence[int | None]</code> <p>The area/volume of the node</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_available_features","title":"get_available_features","text":"<pre><code>get_available_features() -&gt; dict[str, Feature]\n</code></pre> <p>Get all features that can be computed across all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_iou","title":"get_iou","text":"<pre><code>get_iou(edge: Edge)\n</code></pre> <p>Get the IoU value for the given edge.</p> <p>.. deprecated:: 1.0     <code>get_iou</code> will be removed in funtracks v2.0.     Use <code>get_edge_attr(edge, \"iou\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An edge to get the IoU value for.</p> required <p>Returns:</p> Type Description <p>The IoU value for the edge.</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_ious","title":"get_ious","text":"<pre><code>get_ious(edges: Iterable[Edge])\n</code></pre> <p>Get the IoU values for the given edges.</p> <p>.. deprecated:: 1.0     <code>get_ious</code> will be removed in funtracks v2.0.     Use <code>get_edges_attr(edges, \"iou\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[Edge]</code> <p>An iterable of edges to get IoU values for.</p> required <p>Returns:</p> Type Description <p>The IoU values for the edges.</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_pixels","title":"get_pixels","text":"<pre><code>get_pixels(node: Node) -&gt; tuple[np.ndarray, ...] | None\n</code></pre> <p>Get the pixels corresponding to each node in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>A  node to get the pixels for.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ...] | None</code> <p>tuple[np.ndarray, ...] | None: A tuple representing the pixels for the input</p> <code>tuple[ndarray, ...] | None</code> <p>node, or None if the segmentation is None. The tuple will have length equal</p> <code>tuple[ndarray, ...] | None</code> <p>to the number of segmentation dimensions, and can be used to index the</p> <code>tuple[ndarray, ...] | None</code> <p>segmentation.</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_positions","title":"get_positions","text":"<pre><code>get_positions(\n    nodes: Iterable[Node], incl_time: bool = False\n) -&gt; np.ndarray\n</code></pre> <p>Get the positions of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Iterable[Node]</code> <p>The node ids in the graph to get the positions of</p> required <code>incl_time</code> <code>bool</code> <p>If true, include the time as the first element of each position array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A N x ndim numpy array holding the positions, where N is the number of nodes passed in</p>"},{"location":"architecture/#funtracks.data_model.Tracks.get_time","title":"get_time","text":"<pre><code>get_time(node: Node) -&gt; int\n</code></pre> <p>Get the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node id to get the time frame for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The time frame that the node is in</p>"},{"location":"architecture/#funtracks.data_model.Tracks.load","title":"load","text":"<pre><code>load(\n    directory: Path, seg_required=False, solution=False\n) -&gt; Tracks\n</code></pre> <p>Load a Tracks object from the given directory. Looks for files in the format generated by Tracks.save. Args:     directory (Path): The directory containing tracks to load     seg_required (bool, optional): If true, raises a FileNotFoundError if the         segmentation file is not present in the directory. Defaults to False. Returns:     Tracks: A tracks object loaded from the given directory</p>"},{"location":"architecture/#funtracks.data_model.Tracks.notify_annotators","title":"notify_annotators","text":"<pre><code>notify_annotators(action: BasicAction) -&gt; None\n</code></pre> <p>Notify annotators about an action so they can recompute affected features.</p> <p>Delegates to the annotator registry which broadcasts to all annotators. The action contains all necessary information about which elements to update.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this notification</p> required"},{"location":"architecture/#funtracks.data_model.Tracks.save","title":"save","text":"<pre><code>save(directory: Path)\n</code></pre> <p>Save the tracks to the given directory. Currently, saves the graph as a json file in networkx node link data format, saves the segmentation as a numpy npz file, and saves the time and position attributes and scale information in an attributes json file. Args:     directory (Path): The directory to save the tracks in.</p>"},{"location":"architecture/#funtracks.data_model.Tracks.set_pixels","title":"set_pixels","text":"<pre><code>set_pixels(pixels: tuple[ndarray, ...], value: int) -&gt; None\n</code></pre> <p>Set the given pixels in the segmentation to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>pixels</code> <code>Iterable[tuple[ndarray]]</code> <p>The pixels that should be set, formatted like the output of np.nonzero (each element of the tuple represents one dimension, containing an array of indices in that dimension). Can be used to directly index the segmentation.</p> required <code>value</code> <code>Iterable[int | None]</code> <p>The value to set each pixel to</p> required"},{"location":"architecture/#funtracks.data_model.Tracks.set_positions","title":"set_positions","text":"<pre><code>set_positions(\n    nodes: Iterable[Node],\n    positions: ndarray,\n    incl_time: bool = False,\n)\n</code></pre> <p>Set the location of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Iterable[node]</code> <p>The node ids in the graph to set the location of.</p> required <code>positions</code> <code>ndarray</code> <p>An (ndim, num_nodes) shape array of positions to set.</p> required <code>incl_time</code> <code>bool</code> <p>If true, include the time as the first column of the position array. Defaults to False.</p> <code>False</code>"},{"location":"architecture/#funtracks.data_model.Tracks.set_time","title":"set_time","text":"<pre><code>set_time(node: Any, time: int)\n</code></pre> <p>Set the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node id to set the time frame for</p> required <code>time</code> <code>int</code> <p>The time to set</p> required"},{"location":"architecture/#architecture-diagrams","title":"Architecture Diagrams","text":""},{"location":"architecture/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class Feature {\n        &lt;&lt;TypedDict&gt;&gt;\n        +feature_type: Literal\n        +value_type: Literal\n        +num_values: int\n        +display_name: str|Sequence\n        +required: bool\n        +default_value: Any\n    }\n\n    class FeatureDict {\n        +time_key: str\n        +position_key: str|list|None\n        +tracklet_key: str|None\n        +node_features: dict\n        +edge_features: dict\n        +register_position_feature()\n        +register_tracklet_feature()\n    }\n\n    class GraphAnnotator {\n        &lt;&lt;abstract&gt;&gt;\n        +tracks: Tracks\n        +all_features: dict\n        +features: dict\n        +can_annotate()*\n        +activate_features()\n        +deactivate_features()\n        +compute()*\n        +update()*\n    }\n\n    class RegionpropsAnnotator {\n        +pos_key: str\n        +area_key: str\n        +compute()\n        +update()\n    }\n\n    class EdgeAnnotator {\n        +iou_key: str\n        +compute()\n        +update()\n    }\n\n    class TrackAnnotator {\n        +tracklet_key: str\n        +lineage_key: str\n        +tracklet_id_to_nodes: dict\n        +lineage_id_to_nodes: dict\n        +compute()\n        +update()\n    }\n\n    class AnnotatorRegistry {\n        +all_features: dict\n        +features: dict\n        +activate_features()\n        +deactivate_features()\n        +compute()\n        +update()\n    }\n\n    class Tracks {\n        +graph: nx.DiGraph\n        +segmentation: ndarray|None\n        +features: FeatureDict\n        +annotators: AnnotatorRegistry\n        +scale: list|None\n        +ndim: int\n        +enable_features()\n        +disable_features()\n        +get_available_features()\n        +notify_annotators()\n    }\n\n    FeatureDict *-- Feature : stores many\n    GraphAnnotator &lt;|-- RegionpropsAnnotator : implements\n    GraphAnnotator &lt;|-- EdgeAnnotator : implements\n    GraphAnnotator &lt;|-- TrackAnnotator : implements\n    AnnotatorRegistry o-- GraphAnnotator : aggregates many\n    Tracks *-- FeatureDict : has one\n    Tracks *-- AnnotatorRegistry : has one\n    GraphAnnotator --&gt; Tracks : references</code></pre>"},{"location":"architecture/#initialization-lifecycle","title":"Initialization Lifecycle","text":"<p>Here's what happens when you create a <code>Tracks</code> instance.</p> <pre><code>tracks = Tracks(graph, segmentation, ndim=3)\n</code></pre> <ol> <li>Basic Attribute Setup - save graph, segmentation, scale, etc. as instance variables</li> <li>FeatureDict Creation - If features parameter is provided, use the provided FeatureDict and assume all features already exist on the graph. If features=None, create a FeatureDict with static features (time) and provided keys.</li> <li>AnnotatorRegistry Creation - build an <code>AnnotatorRegistry</code> containing any Annotators that work on the provided tracks</li> <li>Core Computed Features Setup - If features parameter provided, activate all computed features with keys in the features dictionary, so that updates will be computed. Does not compute any features from scratch. Otherwise, try to detect which core features are already present, activate those, and compute any missing ones from scratch.</li> </ol>"},{"location":"architecture/#core-features","title":"Core Features","text":"<p>These features are automatically checked during initialization:</p> <ol> <li><code>pos</code> (position): Always auto-detected for RegionpropsAnnotator</li> <li><code>area</code>: Always auto-detected (for backward compatibility)</li> <li><code>track_id</code> (tracklet_id): Always auto-detected for TrackAnnotator</li> </ol>"},{"location":"architecture/#example-scenarios","title":"Example Scenarios","text":"<p>Scenario 1: Loading tracks from CSV with pre-computed features <pre><code># CSV has columns: id, time, y, x, area, track_id\ngraph = load_graph_from_csv(df)  # Nodes already have area, track_id\ntracks = SolutionTracks(graph, segmentation=seg)\n# Auto-detection: pos, area, track_id exist \u2192 activate without recomputing\n</code></pre></p> <p>Scenario 2: Creating tracks from raw segmentation <pre><code># Graph has no features yet\ngraph = nx.DiGraph()\ngraph.add_node(1, time=0)\ntracks = Tracks(graph, segmentation=seg)\n# Auto-detection: pos, area don't exist \u2192 compute them\n</code></pre></p> <p>Scenario 3: Explicit feature control with FeatureDict <pre><code># Bypass auto-detection entirely\nfeature_dict = FeatureDict({\"t\": Time(), \"pos\": Position(), \"area\": Area()})\ntracks = Tracks(graph, segmentation=seg, features=feature_dict)\n# All features in feature_dict are activated, none are computed\n</code></pre></p> <p>Scenario 4: Enable a new feature</p> <pre><code>tracks = Tracks(graph, segmentation)\n# Initially has: time, pos, area (auto-detected or computed)\n\ntracks.enable_features([\"iou\", \"circularity\"])\n# Now has: time, pos, area, iou, circularity\n\n# Check active features\nprint(tracks.features.keys())  # All features in FeatureDict (including static)\nprint(tracks.annotators.features.keys())  # Only active computed features\n</code></pre> <p>Scenario 4: Disable a feature</p> <pre><code>tracks.disable_features([\"area\"])\n# Removes from FeatureDict, deactivates in annotators\n# Note: Doesn't delete values from graph, just stops computing/updating\n</code></pre>"},{"location":"architecture/#extending-the-system","title":"Extending the System","text":""},{"location":"architecture/#creating-a-new-annotator","title":"Creating a New Annotator","text":"<ol> <li> <p>Subclass GraphAnnotator:</p> <pre><code>from funtracks.annotators import GraphAnnotator\n\nclass MyCustomAnnotator(GraphAnnotator):\n    @classmethod\n    def can_annotate(cls, tracks):\n        # Check if this annotator can handle these tracks\n        return tracks.some_condition\n\n    def __init__(self, tracks, custom_key=\"custom\"):\n        super().__init__(tracks)\n        self.custom_key = custom_key\n\n        # Register features\n        self.all_features[custom_key] = (CustomFeature(), False)\n\n    def compute(self, feature_keys=None):\n        # Compute feature values in bulk\n        if \"custom\" in self.features:\n            for node in self.tracks.graph.nodes():\n                value = self._compute_custom(node)\n                self.tracks.graph.nodes[node][\"custom\"] = value\n\n    def update(self, action):\n        # Incremental update when graph changes\n        if \"custom\" in self.features:\n            if isinstance(action, SomeActionType):\n                # Recompute only for affected nodes\n                pass\n</code></pre> </li> <li> <p>Register in Tracks._get_annotators(): <pre><code>if MyCustomAnnotator.can_annotate(tracks):\n    ann = MyCustomAnnotator(tracks)\n    tracks.annotators.append(ann)\n    tracks.enable_features([key for key in ann.all_features()])\n</code></pre></p> </li> </ol>"},{"location":"reference/funtracks/","title":"funtracks","text":""},{"location":"reference/funtracks/#funtracks","title":"funtracks","text":""},{"location":"reference/funtracks/actions/","title":"actions","text":""},{"location":"reference/funtracks/actions/#funtracks.actions","title":"funtracks.actions","text":""},{"location":"reference/funtracks/actions/action_history/","title":"action_history","text":""},{"location":"reference/funtracks/actions/action_history/#funtracks.actions.action_history","title":"funtracks.actions.action_history","text":""},{"location":"reference/funtracks/actions/action_history/#funtracks.actions.action_history.ActionHistory","title":"ActionHistory","text":"<pre><code>ActionHistory()\n</code></pre> <p>An action history implementing the ideas from this blog: https://github.com/zaboople/klonk/blob/master/TheGURQ.md Essentially, if you go back and change something after undo-ing, you can always get back to every state if you undo far enough (instead of throwing out the undone actions)</p>"},{"location":"reference/funtracks/actions/action_history/#funtracks.actions.action_history.ActionHistory.add_new_action","title":"add_new_action","text":"<pre><code>add_new_action(action: Action) -&gt; None\n</code></pre> <p>Add a newly performed action to the history. Args:     action (Action): The new action to be added to the history.</p>"},{"location":"reference/funtracks/actions/action_history/#funtracks.actions.action_history.ActionHistory.redo","title":"redo","text":"<pre><code>redo() -&gt; bool\n</code></pre> <p>Redo the last undone action</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if an action was redone, and False</p> <code>bool</code> <p>if there was no undone action to redo.</p>"},{"location":"reference/funtracks/actions/action_history/#funtracks.actions.action_history.ActionHistory.undo","title":"undo","text":"<pre><code>undo() -&gt; bool\n</code></pre> <p>Undo the last performed action</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if an action was undone, and False</p> <code>bool</code> <p>if there was no previous action to undo.</p>"},{"location":"reference/funtracks/actions/add_delete_edge/","title":"add_delete_edge","text":""},{"location":"reference/funtracks/actions/add_delete_edge/#funtracks.actions.add_delete_edge","title":"funtracks.actions.add_delete_edge","text":""},{"location":"reference/funtracks/actions/add_delete_edge/#funtracks.actions.add_delete_edge.AddEdge","title":"AddEdge","text":"<pre><code>AddEdge(\n    tracks: Tracks,\n    edge: Edge,\n    attributes: dict[str, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action for adding a new edge. Endpoints must exist already.</p> <p>Create an action to add a new edge, with optional attributes.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The Tracks to add the edge to</p> required <code>edge</code> <code>Edge</code> <p>The edge to add (source, target)</p> required <code>attributes</code> <code>dict[str, Any] | None</code> <p>Edge attributes to set. If any computed features are provided, they will be overridden by the Annotator. Defaults to None.</p> <code>None</code>"},{"location":"reference/funtracks/actions/add_delete_edge/#funtracks.actions.add_delete_edge.AddEdge.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Delete edges</p>"},{"location":"reference/funtracks/actions/add_delete_edge/#funtracks.actions.add_delete_edge.DeleteEdge","title":"DeleteEdge","text":"<pre><code>DeleteEdge(tracks: Tracks, edge: Edge)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action for deleting an edge. Edge must exist already.</p> <p>Action for deleting an edge. Edge must exist already.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to delete the edge from</p> required <code>edge</code> <code>Edge</code> <p>The edge to delete</p> required <p>Raises:     ValueError: If the edge does not exist on the graph</p>"},{"location":"reference/funtracks/actions/add_delete_edge/#funtracks.actions.add_delete_edge.DeleteEdge.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Restore edge and their attributes</p>"},{"location":"reference/funtracks/actions/add_delete_node/","title":"add_delete_node","text":""},{"location":"reference/funtracks/actions/add_delete_node/#funtracks.actions.add_delete_node","title":"funtracks.actions.add_delete_node","text":""},{"location":"reference/funtracks/actions/add_delete_node/#funtracks.actions.add_delete_node.AddNode","title":"AddNode","text":"<pre><code>AddNode(\n    tracks: SolutionTracks,\n    node: Node,\n    attributes: dict[str, Any],\n    pixels: SegMask | None = None,\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action for adding new nodes. If a segmentation should also be added, the pixels for each node should be provided. The label to set the pixels will be taken from the node id. The existing pixel values are assumed to be zero - you must explicitly update any other segmentations that were overwritten using an UpdateNodes action if you want to be able to undo the action.</p> <p>Create an action to add a new node, with optional segmentation</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The Tracks to add the node to</p> required <code>node</code> <code>Node</code> <p>A node id</p> required <code>attributes</code> <code>Attrs</code> <p>Includes times, track_ids, and optionally positions</p> required <code>pixels</code> <code>SegMask | None</code> <p>The segmentation associated with the node. Defaults to None.</p> <code>None</code> <p>Raises:     ValueError: If time attribute is not in attributes.     ValueError: If track_id is not in attributes.     ValueError: If pixels is None and position is not in attributes.</p>"},{"location":"reference/funtracks/actions/add_delete_node/#funtracks.actions.add_delete_node.AddNode.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Invert the action to delete nodes instead</p>"},{"location":"reference/funtracks/actions/add_delete_node/#funtracks.actions.add_delete_node.DeleteNode","title":"DeleteNode","text":"<pre><code>DeleteNode(\n    tracks: SolutionTracks,\n    node: Node,\n    pixels: SegMask | None = None,\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action of deleting existing nodes If the tracks contain a segmentation, this action also constructs a reversible operation for setting involved pixels to zero</p>"},{"location":"reference/funtracks/actions/add_delete_node/#funtracks.actions.add_delete_node.DeleteNode.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Invert this action, and provide inverse segmentation operation if given</p>"},{"location":"reference/funtracks/actions/update_node_attrs/","title":"update_node_attrs","text":""},{"location":"reference/funtracks/actions/update_node_attrs/#funtracks.actions.update_node_attrs","title":"funtracks.actions.update_node_attrs","text":""},{"location":"reference/funtracks/actions/update_node_attrs/#funtracks.actions.update_node_attrs.UpdateNodeAttrs","title":"UpdateNodeAttrs","text":"<pre><code>UpdateNodeAttrs(\n    tracks: Tracks, node: Node, attrs: dict[str, Any]\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action for user updates to node attributes. Cannot update protected attributes (time, area, track id), as these are controlled by internal application logic.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to update the node attributes for</p> required <code>node</code> <code>Node</code> <p>The node to update the attributes for</p> required <code>attrs</code> <code>dict[str, Any]</code> <p>A mapping from attribute name to list of new attribute values for the given nodes.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a protected attribute is in the given attribute mapping.</p>"},{"location":"reference/funtracks/actions/update_node_attrs/#funtracks.actions.update_node_attrs.UpdateNodeAttrs.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Restore previous attributes</p>"},{"location":"reference/funtracks/actions/update_segmentation/","title":"update_segmentation","text":""},{"location":"reference/funtracks/actions/update_segmentation/#funtracks.actions.update_segmentation","title":"funtracks.actions.update_segmentation","text":""},{"location":"reference/funtracks/actions/update_segmentation/#funtracks.actions.update_segmentation.UpdateNodeSeg","title":"UpdateNodeSeg","text":"<pre><code>UpdateNodeSeg(\n    tracks: Tracks,\n    node: Node,\n    pixels: SegMask,\n    added: bool = True,\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Action for updating the segmentation associated with a node.</p> <p>New nodes call AddNode with pixels instead of this action.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to update the segmenatations for</p> required <code>node</code> <code>Node</code> <p>The node with updated segmenatation</p> required <code>pixels</code> <code>SegMask</code> <p>The pixels that were updated for the node</p> required <code>added</code> <code>bool</code> <p>If the provided pixels were added (True) or deleted (False) from this node. Defaults to True</p> <code>True</code>"},{"location":"reference/funtracks/actions/update_segmentation/#funtracks.actions.update_segmentation.UpdateNodeSeg.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Restore previous attributes</p>"},{"location":"reference/funtracks/actions/update_track_id/","title":"update_track_id","text":""},{"location":"reference/funtracks/actions/update_track_id/#funtracks.actions.update_track_id","title":"funtracks.actions.update_track_id","text":""},{"location":"reference/funtracks/actions/update_track_id/#funtracks.actions.update_track_id.UpdateTrackID","title":"UpdateTrackID","text":"<pre><code>UpdateTrackID(\n    tracks: SolutionTracks, start_node: Node, track_id: int\n)\n</code></pre> <p>               Bases: <code>BasicAction</code></p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to update</p> required <code>start_node</code> <code>Node</code> <p>The node ID of the first node in the track. All successors with the same track id as this node will be updated.</p> required <code>track_id</code> <code>int</code> <p>The new track id to assign.</p> required"},{"location":"reference/funtracks/actions/update_track_id/#funtracks.actions.update_track_id.UpdateTrackID.inverse","title":"inverse","text":"<pre><code>inverse() -&gt; BasicAction\n</code></pre> <p>Restore the previous track_id</p>"},{"location":"reference/funtracks/annotators/","title":"annotators","text":""},{"location":"reference/funtracks/annotators/#funtracks.annotators","title":"funtracks.annotators","text":""},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry","title":"AnnotatorRegistry","text":"<pre><code>AnnotatorRegistry(annotators: list[GraphAnnotator])\n</code></pre> <p>               Bases: <code>list[GraphAnnotator]</code></p> <p>A list of annotators with coordinated operations.</p> <p>Inherits from list[GraphAnnotator], so can be used directly as a list. Provides coordinated compute/update/enable/disable operations across all annotators.</p> Example <p>annotators = AnnotatorRegistry([     RegionpropsAnnotator(tracks, pos_key=\"centroid\"),     EdgeAnnotator(tracks),     TrackAnnotator(tracks, tracklet_key=\"track_id\"), ])</p> <p>Initialize with a list of annotators.</p> <p>Parameters:</p> Name Type Description Default <code>annotators</code> <code>list[GraphAnnotator]</code> <p>List of instantiated annotator objects</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry--can-use-as-a-list","title":"Can use as a list","text":"<p>annotators.append(MyCustomAnnotator(tracks))</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry--coordinated-operations","title":"Coordinated operations","text":"<p>annotators.activate_features([\"area\", \"iou\"]) annotators.compute()</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.all_features","title":"all_features","text":"<pre><code>all_features: dict[str, tuple[Feature, bool]]\n</code></pre> <p>Dynamically aggregate all_features from all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, tuple[Feature, bool]]</code> <p>Dictionary mapping feature keys to (Feature, is_enabled) tuples</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.features","title":"features","text":"<pre><code>features: dict[str, Feature]\n</code></pre> <p>Get all currently active features from all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions (only active features)</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.activate_features","title":"activate_features","text":"<pre><code>activate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Activate features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to activate</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature keys are not available</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features.</p> <code>None</code>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.deactivate_features","title":"deactivate_features","text":"<pre><code>deactivate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Deactivate features across all annotators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to deactivate</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature keys are not available</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.AnnotatorRegistry.update","title":"update","text":"<pre><code>update(action: BasicAction) -&gt; None\n</code></pre> <p>Update features across all annotators based on the action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.EdgeAnnotator","title":"EdgeAnnotator","text":"<pre><code>EdgeAnnotator(tracks: Tracks)\n</code></pre> <p>               Bases: <code>GraphAnnotator</code></p> <p>Manages edge features computed from segmentations or endpoint positions.</p> <p>The possible features include: - Intersection over Union (IoU)</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to manage the edge features on</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.EdgeAnnotator.can_annotate","title":"can_annotate","text":"<pre><code>can_annotate(tracks) -&gt; bool\n</code></pre> <p>Check if this annotator can annotate the given tracks.</p> <p>Requires segmentation data to be present.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to check compatibility with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if tracks have segmentation, False otherwise</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.EdgeAnnotator.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute the currently included features and add them to the tracks.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features. Keys not in self.features (not enabled) are ignored.</p> <code>None</code>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.EdgeAnnotator.get_available_features","title":"get_available_features","text":"<pre><code>get_available_features(tracks) -&gt; dict[str, Feature]\n</code></pre> <p>Get all features that can be computed by this annotator.</p> <p>Returns features with default keys. Custom keys can be specified at initialization time.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to get available features for</p> required <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions. Empty if no</p> <code>dict[str, Feature]</code> <p>segmentation.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.EdgeAnnotator.update","title":"update","text":"<pre><code>update(action: BasicAction)\n</code></pre> <p>Update the edge features based on the action.</p> <p>Only responds to AddEdge and UpdateNodeSeg actions that affect edge IoU.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator","title":"GraphAnnotator","text":"<pre><code>GraphAnnotator(\n    tracks: Tracks, features: dict[str, Feature]\n)\n</code></pre> <p>A base class for adding and updating graph features.</p> <p>This class holds a set of features that it is responsible for. The annotator will compute these features and add them to the Tracks initially, and update them when necessary. The set of features will all be computed and updated together, although individual ones can be removed for efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to manage features for.</p> required <code>features</code> <code>dict[str, Feature]</code> <p>A dict mapping keys to features that this annotator is capable of computing and updating.</p> required <p>Attributes:</p> Name Type Description <code>all_features</code> <code>dict[str, tuple[Feature, bool]]</code> <p>Maps feature keys to (feature, is_included) tuples. Tracks both what can be computed and what is currently being computed. Defaults to computing nothing.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.features","title":"features","text":"<pre><code>features: dict[str, Feature]\n</code></pre> <p>The dict of features that this annotator currently manages.</p> <p>Filtered from all_features based on inclusion flags.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.activate_features","title":"activate_features","text":"<pre><code>activate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Activate computation of the given features in the annotation process.</p> <p>Filters the list to only features this annotator owns, ignoring others.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to activate. Only keys in all_features are activated.</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.can_annotate","title":"can_annotate","text":"<pre><code>can_annotate(tracks: Tracks) -&gt; bool\n</code></pre> <p>Check if this annotator can annotate the given tracks.</p> <p>Subclasses should override this method to specify their requirements (e.g., segmentation, SolutionTracks, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>The tracks to check compatibility with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the annotator can annotate these tracks, False otherwise</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute a set of features and add them to the tracks.</p> <p>This involves both updating the node/edge attributes on the tracks.graph and adding the features to the FeatureDict, if necessary. This is distinct from <code>update</code> to allow more efficient bulk computation of features.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features. Any provided keys not in the currently active set are ignored.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.deactivate_features","title":"deactivate_features","text":"<pre><code>deactivate_features(keys: list[str]) -&gt; None\n</code></pre> <p>Deactivate computation of the given features in the annotation process.</p> <p>Filters the list to only features this annotator owns, ignoring others.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of feature keys to deactivate. Only keys in all_features are deactivated.</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.GraphAnnotator.update","title":"update","text":"<pre><code>update(action: BasicAction) -&gt; None\n</code></pre> <p>Update a set of features based on the given action.</p> <p>This involves both updating the node or edge attributes on the tracks.graph and adding the features to the FeatureDict, if necessary. This is distinct from <code>compute</code> to allow more efficient computation of features for single elements.</p> <p>The action contains all necessary information about which elements to update (e.g., AddNode.node, AddEdge.edge, UpdateNodeSeg.node).</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented in subclass.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.RegionpropsAnnotator","title":"RegionpropsAnnotator","text":"<pre><code>RegionpropsAnnotator(\n    tracks: Tracks, pos_key: str | None = DEFAULT_POS_KEY\n)\n</code></pre> <p>               Bases: <code>GraphAnnotator</code></p> <p>A graph annotator using regionprops to extract node features from segmentations.</p> <p>The possible features include: - centroid (to use as node position) - area/volume - ellipsoid major/minor/semi-minor axes - circularity/sphericity - perimeter/surface area</p> <p>Defaults to computing all features, but individual ones can be turned off by changing the self.include value at the corresponding index to the feature in self.features.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.RegionpropsAnnotator.can_annotate","title":"can_annotate","text":"<pre><code>can_annotate(tracks) -&gt; bool\n</code></pre> <p>Check if this annotator can annotate the given tracks.</p> <p>Requires segmentation data to be present.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to check compatibility with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if tracks have segmentation, False otherwise</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.RegionpropsAnnotator.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute the currently included features and add them to the tracks.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features. Keys not in self.features (not enabled) are ignored.</p> <code>None</code>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.RegionpropsAnnotator.get_available_features","title":"get_available_features","text":"<pre><code>get_available_features(tracks) -&gt; dict[str, Feature]\n</code></pre> <p>Get all features that can be computed by this annotator.</p> <p>Returns features with default keys. Custom keys can be specified at initialization time.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to get available features for</p> required <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions. Empty if no</p> <code>dict[str, Feature]</code> <p>segmentation.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.RegionpropsAnnotator.update","title":"update","text":"<pre><code>update(action: BasicAction)\n</code></pre> <p>Update the regionprops features based on the action.</p> <p>Only responds to AddNode and UpdateNodeSeg actions that affect segmentation.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required"},{"location":"reference/funtracks/annotators/#funtracks.annotators.TrackAnnotator","title":"TrackAnnotator","text":"<pre><code>TrackAnnotator(\n    tracks: SolutionTracks,\n    tracklet_key: str | None = DEFAULT_TRACKLET_KEY,\n    lineage_key: str | None = DEFAULT_LINEAGE_KEY,\n)\n</code></pre> <p>               Bases: <code>GraphAnnotator</code></p> <p>A graph annotator to compute tracklet and lineage IDs for SolutionTracks only.</p> <p>Currently, updating the tracklet and lineage IDs is left to Actions.</p> <p>Attributes:</p> Name Type Description <code>tracklet_id_to_nodes</code> <code>dict[int, list[int]]</code> <p>A mapping from tracklet ids to nodes in that tracklet</p> <code>lineage_id_to_nodes</code> <code>dict[int, list[int]]</code> <p>A mapping from lineage ids to nodes in that lineage</p> <code>max_tracklet_id</code> <code>int</code> <p>the maximum tracklet id used in the tracks</p> <code>max_lineage_id</code> <code>int</code> <p>the maximum lineage id used in the tracks</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>SolutionTracks</code> <p>The tracks to be annotated. Must be a solution.</p> required <code>tracklet_key</code> <code>str | None</code> <p>A key that already holds the tracklet ids on the graph. If provided, must be there for every node and already hold valid tracklet ids. Defaults to None.</p> <code>DEFAULT_TRACKLET_KEY</code> <code>lineage_key</code> <code>str | None</code> <p>A key that already holds the lineage ids on the graph. If provided, must be there for every node and already hold valid lineage ids. Defaults to None.</p> <code>DEFAULT_LINEAGE_KEY</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the provided Tracks are not SolutionTracks (not a binary lineage tree)</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.TrackAnnotator.can_annotate","title":"can_annotate","text":"<pre><code>can_annotate(tracks) -&gt; bool\n</code></pre> <p>Check if this annotator can annotate the given tracks.</p> <p>Requires tracks to be a SolutionTracks instance.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to check compatibility with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if tracks is a SolutionTracks instance, False otherwise</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.TrackAnnotator.compute","title":"compute","text":"<pre><code>compute(feature_keys: list[str] | None = None) -&gt; None\n</code></pre> <p>Compute the currently included features and add them to the tracks.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str] | None</code> <p>Optional list of specific feature keys to compute. If None, computes all currently active features. Keys not in self.features (not enabled) are ignored.</p> <code>None</code>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.TrackAnnotator.get_available_features","title":"get_available_features","text":"<pre><code>get_available_features(tracks) -&gt; dict[str, Feature]\n</code></pre> <p>Get all features that can be computed by this annotator.</p> <p>Returns features with default keys. Custom keys can be specified at initialization time.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <p>The tracks to get available features for</p> required <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions. Empty if not</p> <code>dict[str, Feature]</code> <p>SolutionTracks.</p>"},{"location":"reference/funtracks/annotators/#funtracks.annotators.TrackAnnotator.update","title":"update","text":"<pre><code>update(action: BasicAction) -&gt; None\n</code></pre> <p>Update track-level features based on the action.</p> <p>Handles incremental updates for UpdateTrackID, AddNode, and DeleteNode actions. Other actions are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this update</p> required"},{"location":"reference/funtracks/data_model/","title":"data_model","text":""},{"location":"reference/funtracks/data_model/#funtracks.data_model","title":"funtracks.data_model","text":""},{"location":"reference/funtracks/data_model/graph_attributes/","title":"graph_attributes","text":""},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes","title":"funtracks.data_model.graph_attributes","text":""},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.DeprecatedEnumMeta","title":"DeprecatedEnumMeta","text":"<p>               Bases: <code>EnumMeta</code></p> <p>Metaclass for deprecated enums that issues warnings on member access.</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.DeprecatedEnumMeta.__getattribute__","title":"__getattribute__","text":"<pre><code>__getattribute__(name)\n</code></pre> <p>Issue deprecation warning when accessing enum members.</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.EdgeAttr","title":"EdgeAttr","text":"<p>               Bases: <code>Enum</code></p> <p>Edge attributes that can be added to candidate graph.</p> <p>.. deprecated:: 2.0     EdgeAttr enum will be removed in funtracks v2.0. Use string keys directly     (e.g., \"iou\").</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.NodeAttr","title":"NodeAttr","text":"<p>               Bases: <code>Enum</code></p> <p>Node attributes that can be added to candidate graph.</p> <p>.. deprecated:: 2.0     NodeAttr enum will be removed in funtracks v2.0. Use string keys from     tracks.features instead (e.g., tracks.features.position_key, \"area\", etc.).</p>"},{"location":"reference/funtracks/data_model/graph_attributes/#funtracks.data_model.graph_attributes.NodeType","title":"NodeType","text":"<p>               Bases: <code>Enum</code></p> <p>Types of nodes in the track graph. Currently used for standardizing visualization. All nodes are exactly one type.</p> <p>.. deprecated:: 2.0     NodeType will be removed in funtracks v2.0. This is a visualization     concern and should be moved to motile_tracker.</p>"},{"location":"reference/funtracks/data_model/solution_tracks/","title":"solution_tracks","text":""},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks","title":"funtracks.data_model.solution_tracks","text":""},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks","title":"SolutionTracks","text":"<pre><code>SolutionTracks(\n    graph: DiGraph,\n    segmentation: ndarray | None = None,\n    time_attr: str | None = None,\n    pos_attr: str | tuple[str] | list[str] | None = None,\n    tracklet_attr: str | None = None,\n    scale: list[float] | None = None,\n    ndim: int | None = None,\n    features: FeatureDict | None = None,\n)\n</code></pre> <p>               Bases: <code>Tracks</code></p> <p>Difference from Tracks: every node must have a track_id</p> <p>Initialize a SolutionTracks object.</p> <p>SolutionTracks extends Tracks to ensure every node has a track_id. A TrackAnnotator is automatically added to manage track IDs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>NetworkX directed graph with nodes as detections and edges as links.</p> required <code>segmentation</code> <code>ndarray | None</code> <p>Optional segmentation array where labels match node IDs. Required for computing region properties (area, etc.).</p> <code>None</code> <code>time_attr</code> <code>str | None</code> <p>Graph attribute name for time. Defaults to \"time\" if None.</p> <code>None</code> <code>pos_attr</code> <code>str | tuple[str, ...] | list[str] | None</code> <p>Graph attribute name(s) for position. Can be: - Single string for one attribute containing position array - List/tuple of strings for multi-axis (one attribute per axis) Defaults to \"pos\" if None.</p> <code>None</code> <code>tracklet_attr</code> <code>str | None</code> <p>Graph attribute name for tracklet/track IDs. Defaults to \"track_id\" if None.</p> <code>None</code> <code>scale</code> <code>list[float] | None</code> <p>Scaling factors for each dimension (including time). If None, all dimensions scaled by 1.0.</p> <code>None</code> <code>ndim</code> <code>int | None</code> <p>Number of dimensions (3 for 2D+time, 4 for 3D+time). If None, inferred from segmentation or scale.</p> <code>None</code> <code>features</code> <code>FeatureDict | None</code> <p>Pre-built FeatureDict with feature definitions. If provided, time_attr/pos_attr/tracklet_attr are ignored. Assumes that all features in the dict already exist on the graph (will be activated but not recomputed). If None, core computed features (pos, area, track_id) are auto-detected by checking if they exist on the graph.</p> <code>None</code>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.export_tracks","title":"export_tracks","text":"<pre><code>export_tracks(\n    outfile: Path | str, node_ids: set[int] | None = None\n) -&gt; None\n</code></pre> <p>Export the tracks from this run to a csv with the following columns: t,[z],y,x,id,parent_id,track_id Cells without a parent_id will have an empty string for the parent_id. Whether or not to include z is inferred from self.ndim</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>Path</code> <p>path to output csv file</p> required <code>node_ids</code> <code>set[int]</code> <p>nodes to be included. If provided, only these</p> <code>None</code>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.get_next_track_id","title":"get_next_track_id","text":"<pre><code>get_next_track_id() -&gt; int\n</code></pre> <p>Return the next available track_id and update max_tracklet_id in TrackAnnotator</p>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.get_next_track_id--todo-i-dont-think-we-need-to-update-the-max-here-it-will-get-updated-if-we","title":"TODO: I don't think we need to update the max here, it will get updated if we","text":"<p>actually add a node automatically.</p>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.get_track_neighbors","title":"get_track_neighbors","text":"<pre><code>get_track_neighbors(\n    track_id: int, time: int\n) -&gt; tuple[Node | None, Node | None]\n</code></pre> <p>Get the last node with the given track id before time, and the first node with the track id after time, if any. Does not assume that a node with the given track_id and time is already in tracks, but it can be.</p> <p>Parameters:</p> Name Type Description Default <code>track_id</code> <code>int</code> <p>The track id to search for</p> required <code>time</code> <code>int</code> <p>The time point to find the immediate predecessor and successor for</p> required <p>Returns:</p> Type Description <code>Node | None</code> <p>tuple[Node | None, Node | None]: The last node before time with the given</p> <code>Node | None</code> <p>track id, and the first node after time with the given track id,</p> <code>tuple[Node | None, Node | None]</code> <p>or Nones if there are no such nodes.</p>"},{"location":"reference/funtracks/data_model/solution_tracks/#funtracks.data_model.solution_tracks.SolutionTracks.has_track_id_at_time","title":"has_track_id_at_time","text":"<pre><code>has_track_id_at_time(track_id: int, time: int) -&gt; bool\n</code></pre> <p>Function to check if a node with given track id exists at given time point.</p> <p>Parameters:</p> Name Type Description Default <code>track_id</code> <code>int</code> <p>The track id to search for.</p> required <code>time</code> <code>int</code> <p>The time point to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a node with given track id exists at given time point.</p>"},{"location":"reference/funtracks/data_model/tracks/","title":"tracks","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks","title":"funtracks.data_model.tracks","text":""},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks","title":"Tracks","text":"<pre><code>Tracks(\n    graph: DiGraph,\n    segmentation: ndarray | None = None,\n    time_attr: str | None = None,\n    pos_attr: str\n    | tuple[str, ...]\n    | list[str]\n    | None = None,\n    tracklet_attr: str | None = None,\n    scale: list[float] | None = None,\n    ndim: int | None = None,\n    features: FeatureDict | None = None,\n)\n</code></pre> <p>A set of tracks consisting of a graph and an optional segmentation.</p> <p>The graph nodes represent detections and must have a time attribute and position attribute. Edges in the graph represent links across time.</p> <p>Attributes:</p> Name Type Description <code>graph</code> <code>DiGraph</code> <p>A graph with nodes representing detections and and edges representing links across time.</p> <code>segmentation</code> <code>ndarray | None</code> <p>An optional segmentation that accompanies the tracking graph. If a segmentation is provided, the node ids in the graph must match the segmentation labels.</p> <code>features</code> <code>FeatureDict</code> <p>Dictionary of features tracked on graph nodes/edges.</p> <code>annotators</code> <code>AnnotatorRegistry</code> <p>List of annotators that compute features.</p> <code>scale</code> <code>list[float] | None</code> <p>How much to scale each dimension by, including time.</p> <code>ndim</code> <code>int</code> <p>Number of dimensions (3 for 2D+time, 4 for 3D+time).</p> <p>Initialize a Tracks object.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>NetworkX directed graph with nodes as detections and edges as links.</p> required <code>segmentation</code> <code>ndarray | None</code> <p>Optional segmentation array where labels match node IDs. Required for computing region properties (area, etc.).</p> <code>None</code> <code>time_attr</code> <code>str | None</code> <p>Graph attribute name for time. Defaults to \"time\" if None.</p> <code>None</code> <code>pos_attr</code> <code>str | tuple[str, ...] | list[str] | None</code> <p>Graph attribute name(s) for position. Can be: - Single string for one attribute containing position array - List/tuple of strings for multi-axis (one attribute per axis) Defaults to \"pos\" if None.</p> <code>None</code> <code>tracklet_attr</code> <code>str | None</code> <p>Graph attribute name for tracklet/track IDs. Defaults to \"track_id\" if None.</p> <code>None</code> <code>scale</code> <code>list[float] | None</code> <p>Scaling factors for each dimension (including time). If None, all dimensions scaled by 1.0.</p> <code>None</code> <code>ndim</code> <code>int | None</code> <p>Number of dimensions (3 for 2D+time, 4 for 3D+time). If None, inferred from segmentation or scale.</p> <code>None</code> <code>features</code> <code>FeatureDict | None</code> <p>Pre-built FeatureDict with feature definitions. If provided, time_attr/pos_attr/tracklet_attr are ignored. Assumes that all features in the dict already exist on the graph (will be activated but not recomputed). If None, core computed features (pos, area, track_id) are auto-detected by checking if they exist on the graph.</p> <code>None</code>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.delete","title":"delete","text":"<pre><code>delete(directory: Path)\n</code></pre> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>Directory containing tracks to be deleted</p> required"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.disable_features","title":"disable_features","text":"<pre><code>disable_features(feature_keys: list[str]) -&gt; None\n</code></pre> <p>Disable multiple features from computation.</p> <p>Removes features from annotators and FeatureDict.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str]</code> <p>List of feature keys to disable</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature is not available (raised by annotators)</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.enable_features","title":"enable_features","text":"<pre><code>enable_features(feature_keys: list[str]) -&gt; None\n</code></pre> <p>Enable multiple features for computation efficiently.</p> <p>Adds features to annotators and FeatureDict, then computes their values.</p> <p>Parameters:</p> Name Type Description Default <code>feature_keys</code> <code>list[str]</code> <p>List of feature keys to enable</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If any feature is not available (raised by annotators)</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_area","title":"get_area","text":"<pre><code>get_area(node: Node) -&gt; int | None\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>.. deprecated:: 1.0     <code>get_area</code> will be removed in funtracks v2.0.     Use <code>get_node_attr(node, \"area\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int | None</code> <p>The area/volume of the node</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_areas","title":"get_areas","text":"<pre><code>get_areas(nodes: Iterable[Node]) -&gt; Sequence[int | None]\n</code></pre> <p>Get the area/volume of a given node. Raises a KeyError if the node is not in the graph. Returns None if the given node does not have an Area attribute.</p> <p>.. deprecated:: 1.0     <code>get_areas</code> will be removed in funtracks v2.0.     Use <code>get_nodes_attr(nodes, \"area\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node id to get the area/volume for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Sequence[int | None]</code> <p>The area/volume of the node</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_available_features","title":"get_available_features","text":"<pre><code>get_available_features() -&gt; dict[str, Feature]\n</code></pre> <p>Get all features that can be computed across all annotators.</p> <p>Returns:</p> Type Description <code>dict[str, Feature]</code> <p>Dictionary mapping feature keys to Feature definitions</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_iou","title":"get_iou","text":"<pre><code>get_iou(edge: Edge)\n</code></pre> <p>Get the IoU value for the given edge.</p> <p>.. deprecated:: 1.0     <code>get_iou</code> will be removed in funtracks v2.0.     Use <code>get_edge_attr(edge, \"iou\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>An edge to get the IoU value for.</p> required <p>Returns:</p> Type Description <p>The IoU value for the edge.</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_ious","title":"get_ious","text":"<pre><code>get_ious(edges: Iterable[Edge])\n</code></pre> <p>Get the IoU values for the given edges.</p> <p>.. deprecated:: 1.0     <code>get_ious</code> will be removed in funtracks v2.0.     Use <code>get_edges_attr(edges, \"iou\")</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[Edge]</code> <p>An iterable of edges to get IoU values for.</p> required <p>Returns:</p> Type Description <p>The IoU values for the edges.</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_pixels","title":"get_pixels","text":"<pre><code>get_pixels(node: Node) -&gt; tuple[np.ndarray, ...] | None\n</code></pre> <p>Get the pixels corresponding to each node in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>A  node to get the pixels for.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ...] | None</code> <p>tuple[np.ndarray, ...] | None: A tuple representing the pixels for the input</p> <code>tuple[ndarray, ...] | None</code> <p>node, or None if the segmentation is None. The tuple will have length equal</p> <code>tuple[ndarray, ...] | None</code> <p>to the number of segmentation dimensions, and can be used to index the</p> <code>tuple[ndarray, ...] | None</code> <p>segmentation.</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_positions","title":"get_positions","text":"<pre><code>get_positions(\n    nodes: Iterable[Node], incl_time: bool = False\n) -&gt; np.ndarray\n</code></pre> <p>Get the positions of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Iterable[Node]</code> <p>The node ids in the graph to get the positions of</p> required <code>incl_time</code> <code>bool</code> <p>If true, include the time as the first element of each position array. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A N x ndim numpy array holding the positions, where N is the number of nodes passed in</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.get_time","title":"get_time","text":"<pre><code>get_time(node: Node) -&gt; int\n</code></pre> <p>Get the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node id to get the time frame for</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The time frame that the node is in</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.load","title":"load","text":"<pre><code>load(\n    directory: Path, seg_required=False, solution=False\n) -&gt; Tracks\n</code></pre> <p>Load a Tracks object from the given directory. Looks for files in the format generated by Tracks.save. Args:     directory (Path): The directory containing tracks to load     seg_required (bool, optional): If true, raises a FileNotFoundError if the         segmentation file is not present in the directory. Defaults to False. Returns:     Tracks: A tracks object loaded from the given directory</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.notify_annotators","title":"notify_annotators","text":"<pre><code>notify_annotators(action: BasicAction) -&gt; None\n</code></pre> <p>Notify annotators about an action so they can recompute affected features.</p> <p>Delegates to the annotator registry which broadcasts to all annotators. The action contains all necessary information about which elements to update.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>BasicAction</code> <p>The action that triggered this notification</p> required"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.save","title":"save","text":"<pre><code>save(directory: Path)\n</code></pre> <p>Save the tracks to the given directory. Currently, saves the graph as a json file in networkx node link data format, saves the segmentation as a numpy npz file, and saves the time and position attributes and scale information in an attributes json file. Args:     directory (Path): The directory to save the tracks in.</p>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_pixels","title":"set_pixels","text":"<pre><code>set_pixels(pixels: tuple[ndarray, ...], value: int) -&gt; None\n</code></pre> <p>Set the given pixels in the segmentation to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>pixels</code> <code>Iterable[tuple[ndarray]]</code> <p>The pixels that should be set, formatted like the output of np.nonzero (each element of the tuple represents one dimension, containing an array of indices in that dimension). Can be used to directly index the segmentation.</p> required <code>value</code> <code>Iterable[int | None]</code> <p>The value to set each pixel to</p> required"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_positions","title":"set_positions","text":"<pre><code>set_positions(\n    nodes: Iterable[Node],\n    positions: ndarray,\n    incl_time: bool = False,\n)\n</code></pre> <p>Set the location of nodes in the graph. Optionally include the time frame as the first dimension. Raises an error if any of the nodes are not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Iterable[node]</code> <p>The node ids in the graph to set the location of.</p> required <code>positions</code> <code>ndarray</code> <p>An (ndim, num_nodes) shape array of positions to set.</p> required <code>incl_time</code> <code>bool</code> <p>If true, include the time as the first column of the position array. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/data_model/tracks/#funtracks.data_model.tracks.Tracks.set_time","title":"set_time","text":"<pre><code>set_time(node: Any, time: int)\n</code></pre> <p>Set the time frame of a given node. Raises an error if the node is not in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>The node id to set the time frame for</p> required <code>time</code> <code>int</code> <p>The time to set</p> required"},{"location":"reference/funtracks/data_model/tracks_controller/","title":"tracks_controller","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller","title":"funtracks.data_model.tracks_controller","text":""},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController","title":"TracksController","text":"<pre><code>TracksController(tracks: SolutionTracks)\n</code></pre> <p>A set of high level functions to change the data model. All changes to the data should go through this API.</p>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_edges","title":"add_edges","text":"<pre><code>add_edges(\n    edges: Iterable[Edge], force: bool = False\n) -&gt; None\n</code></pre> <p>Add edges to the graph. Also update the track ids and corresponding segmentations if applicable</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[Edge]</code> <p>An iterable of edges, each with source and target node ids</p> required <code>force</code> <code>bool</code> <p>Whether to force this operation by removing conflicting edges. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(\n    attributes: Attrs,\n    pixels: list[SegMask] | None = None,\n    force: bool = False,\n) -&gt; None\n</code></pre> <p>Calls the _add_nodes function to add nodes. Calls the refresh signal when finished.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Attrs</code> <p>dictionary containing at least time and position attributes</p> required <code>pixels</code> <code>list[SegMask] | None</code> <p>The pixels associated with each node, if a segmentation is present. Defaults to None.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to force the operation by removing conflicting edges. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_edges","title":"delete_edges","text":"<pre><code>delete_edges(edges: Iterable[Edge])\n</code></pre> <p>Delete edges from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>Iterable[Edge]</code> <p>The Nx2 array of edges to be deleted</p> required"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.delete_nodes","title":"delete_nodes","text":"<pre><code>delete_nodes(nodes: Iterable[Node]) -&gt; None\n</code></pre> <p>Calls the _delete_nodes function and then emits the refresh signal</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Iterable[Node]</code> <p>array of node_ids to be deleted</p> required"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.is_valid","title":"is_valid","text":"<pre><code>is_valid(edge: Edge) -&gt; bool\n</code></pre> <p>Check if this edge is valid. Criteria: - not horizontal - not existing yet - no triple divisions - new edge should be the shortest possible connection between two nodes, given     their track_ids (no skipping/bypassing any nodes of the same track_id).     Check if there are any nodes of the same source or target track_id between     source and target</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>edge to be validated</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is valid, false if invalid</p>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.redo","title":"redo","text":"<pre><code>redo() -&gt; bool\n</code></pre> <p>Obtain the action to redo from the history Returns:     bool: True if the action was re-done, False if there were no more actions</p>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.undo","title":"undo","text":"<pre><code>undo() -&gt; bool\n</code></pre> <p>Obtain the action to undo from the history, and invert. Returns:     bool: True if the action was undone, False if there were no more actions</p>"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(nodes: Iterable[Node], attributes: Attrs)\n</code></pre> <p>Update the user provided node attributes (not the managed attributes). Also adds the action to the history and emits the refresh signal.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Iterable[Node]</code> <p>The nodes to update the attributes for</p> required <code>attributes</code> <code>Attrs</code> <p>A mapping from user-provided attributes to values for each node.</p> required"},{"location":"reference/funtracks/data_model/tracks_controller/#funtracks.data_model.tracks_controller.TracksController.update_segmentations","title":"update_segmentations","text":"<pre><code>update_segmentations(\n    new_value: int,\n    updated_pixels: list[tuple[SegMask, int]],\n    current_timepoint: int,\n    current_track_id: int,\n    force: bool = False,\n)\n</code></pre> <p>Handle a change in the segmentation mask, checking for node addition, deletion, and attribute updates.</p> <p>NOTE: we have introduced a minor breaking change to this API that finn will need to adapt to - it used to parse the pixel change into different action lists, but that is now done in the UserUpdateSegmentation action</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>int)</code> <p>the label that the user drew with</p> required <code>updated_pixels</code> <code>list[tuple[SegMask, int]]</code> <p>a list of pixels changed and the value that was there before the user drew</p> required <code>current_timepoint</code> <code>int</code> <p>the current time point in the viewer, used to set the selected node.</p> required <code>current_track_id</code> <code>int</code> <p>the track_id to use when adding a new node, usually the currently selected track id in the viewer</p> required <code>force</code> <code>bool</code> <p>Whether to force the operation by removing conflicting edges. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/exceptions/","title":"exceptions","text":""},{"location":"reference/funtracks/exceptions/#funtracks.exceptions","title":"funtracks.exceptions","text":""},{"location":"reference/funtracks/exceptions/#funtracks.exceptions.InvalidActionError","title":"InvalidActionError","text":"<pre><code>InvalidActionError(message: str, forceable: bool = False)\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Raised when attempting an action that by itself is invalid, but that can optionally be forced by removing conflicting edges.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required <code>forceable</code> <code>bool</code> <p>Whether the action can be forced. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/features/","title":"features","text":""},{"location":"reference/funtracks/features/#funtracks.features","title":"funtracks.features","text":""},{"location":"reference/funtracks/features/#funtracks.features.Feature","title":"Feature","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for storing metadata associated with a graph feature.</p> <p>Use factory functions like Time(), Position(), Area() etc. to create features with standard defaults.</p> <p>The key is stored separately in the FeatureDict mapping (not in the Feature itself).</p> <p>Attributes:</p> Name Type Description <code>feature_type</code> <code>Literal['node', 'edge']</code> <p>Specifies which graph elements the feature applies to.</p> <code>value_type</code> <code>Literal['int', 'float', 'str', 'bool']</code> <p>The data type of the feature values.</p> <code>num_values</code> <code>int</code> <p>The number of values expected for this feature.</p> <code>display_name</code> <code>str | Sequence[str] | None</code> <p>The name to use to display the feature.</p> <code>required</code> <code>bool</code> <p>If True, all nodes/edges in the graph are required to have this feature.</p> <code>default_value</code> <code>Any</code> <p>If required is False, this value is returned whenever the feature value is missing on the graph.</p>"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict","title":"FeatureDict","text":"<pre><code>FeatureDict(\n    features: dict[str, Feature],\n    time_key: str,\n    position_key: str | list[str] | None,\n    tracklet_key: str | None,\n)\n</code></pre> <p>               Bases: <code>dict[str, Feature]</code></p> <p>A dictionary mapping keys to Features, with special tracking for time/position.</p> <p>Inherits from dict[str, Feature], so can be used directly as a dictionary. Provides convenient access to time and position features through properties.</p> <p>Attributes:</p> Name Type Description <code>time_key</code> <code>str</code> <p>The key used for the time feature</p> <code>position_key</code> <code>str | list[str] | None</code> <p>The key(s) used for position feature(s)</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>dict[str, Feature]</code> <p>Mapping from feature keys to Features</p> required <code>time_key</code> <code>str</code> <p>The key for the time feature (must be in features)</p> required <code>position_key</code> <code>str | list[str] | None</code> <p>The key(s) for position feature(s)</p> required <code>tracklet_key</code> <code>str | None</code> <p>The key for the tracklet feature</p> required"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.edge_features","title":"edge_features","text":"<pre><code>edge_features: dict[str, Feature]\n</code></pre> <p>A dict of all edge features</p>"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.node_features","title":"node_features","text":"<pre><code>node_features: dict[str, Feature]\n</code></pre> <p>A dict of all node features</p>"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.dump_json","title":"dump_json","text":"<pre><code>dump_json() -&gt; dict\n</code></pre> <p>Dump this FeatureDict to a json compatible dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A map from the key \"FeatureDict\" containing features, time_key, position_key, and tracklet_key</p>"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.from_json","title":"from_json","text":"<pre><code>from_json(json_dict: dict) -&gt; FeatureDict\n</code></pre> <p>Generate a FeatureDict from a json dict such as one generated by dump_json</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict</code> <p>A dictionary with the key \"FeatureDict\" containing features, time_key, position_key, and tracklet_key</p> required <p>Returns:</p> Name Type Description <code>FeatureDict</code> <code>FeatureDict</code> <p>A FeatureDict object containing the features from the dictionary</p>"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.register_position_feature","title":"register_position_feature","text":"<pre><code>register_position_feature(\n    key: str, feature: Feature\n) -&gt; None\n</code></pre> <p>Register the position feature and set the position_key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to use for the position feature</p> required <code>feature</code> <code>Feature</code> <p>The Feature to register</p> required"},{"location":"reference/funtracks/features/#funtracks.features.FeatureDict.register_tracklet_feature","title":"register_tracklet_feature","text":"<pre><code>register_tracklet_feature(\n    key: str, feature: Feature\n) -&gt; None\n</code></pre> <p>Register the tracklet/track_id feature and set the tracklet_key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to use for the tracklet feature</p> required <code>feature</code> <code>Feature</code> <p>The Feature to register</p> required"},{"location":"reference/funtracks/features/#funtracks.features.Area","title":"Area","text":"<pre><code>Area(ndim: int = 3) -&gt; Feature\n</code></pre> <p>A regionprops feature for computing area or volume.</p> <p>Parameters:</p> Name Type Description Default <code>ndim</code> <code>int</code> <p>The number of dimensions of the tracks. Controls the display name.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing area/volume</p>"},{"location":"reference/funtracks/features/#funtracks.features.Circularity","title":"Circularity","text":"<pre><code>Circularity(ndim: int = 3) -&gt; Feature\n</code></pre> <p>A regionprops feature for computing the circularity or sphericity.</p> <p>Parameters:</p> Name Type Description Default <code>ndim</code> <code>int</code> <p>The number of dimensions of the tracks. Controls the display name.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing circularity/sphericity</p>"},{"location":"reference/funtracks/features/#funtracks.features.EllipsoidAxes","title":"EllipsoidAxes","text":"<pre><code>EllipsoidAxes(ndim: int = 3) -&gt; Feature\n</code></pre> <p>A regionprops feature for computing the ellipsoid axis radii.</p> <p>Parameters:</p> Name Type Description Default <code>ndim</code> <code>int</code> <p>The number of dimensions of the tracks. Controls the display name.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing ellipsoid axes</p>"},{"location":"reference/funtracks/features/#funtracks.features.Intensity","title":"Intensity","text":"<pre><code>Intensity() -&gt; Feature\n</code></pre> <p>A regionprops feature for computing the intensity.</p> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing intensity</p>"},{"location":"reference/funtracks/features/#funtracks.features.IoU","title":"IoU","text":"<pre><code>IoU() -&gt; Feature\n</code></pre> <p>A feature representing Intersection over Union for edges.</p> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing IoU</p>"},{"location":"reference/funtracks/features/#funtracks.features.LineageID","title":"LineageID","text":"<pre><code>LineageID() -&gt; Feature\n</code></pre> <p>A feature representing lineage ID for nodes.</p> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing lineage ID</p>"},{"location":"reference/funtracks/features/#funtracks.features.Perimeter","title":"Perimeter","text":"<pre><code>Perimeter(ndim: int = 3) -&gt; Feature\n</code></pre> <p>A regionprops feature for computing perimeter or surface area.</p> <p>Parameters:</p> Name Type Description Default <code>ndim</code> <code>int</code> <p>The number of dimensions of the tracks. Controls the display name.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing perimeter/surface area</p>"},{"location":"reference/funtracks/features/#funtracks.features.Position","title":"Position","text":"<pre><code>Position(axes: Sequence[str]) -&gt; Feature\n</code></pre> <p>A feature to hold the position of a node (time not included).</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Sequence[str]</code> <p>A sequence of the axis names. Used to infer the number of dimensions of the position values.</p> required <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing position</p>"},{"location":"reference/funtracks/features/#funtracks.features.Time","title":"Time","text":"<pre><code>Time() -&gt; Feature\n</code></pre> <p>A feature to hold the integer time frame a node is in.</p> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing time</p>"},{"location":"reference/funtracks/features/#funtracks.features.TrackletID","title":"TrackletID","text":"<pre><code>TrackletID() -&gt; Feature\n</code></pre> <p>A feature representing tracklet ID for nodes.</p> <p>Returns:</p> Name Type Description <code>Feature</code> <code>Feature</code> <p>A feature dict representing tracklet ID</p>"},{"location":"reference/funtracks/import_export/","title":"import_export","text":""},{"location":"reference/funtracks/import_export/#funtracks.import_export","title":"funtracks.import_export","text":""},{"location":"reference/funtracks/import_export/export_to_geff/","title":"export_to_geff","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff","title":"funtracks.import_export.export_to_geff","text":""},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.export_to_geff","title":"export_to_geff","text":"<pre><code>export_to_geff(\n    tracks: Tracks,\n    directory: Path,\n    overwrite: bool = False,\n    node_ids: set[int] | None = None,\n)\n</code></pre> <p>Export the Tracks nxgraph to geff.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>Tracks object containing a graph to save.</p> required <code>directory</code> <code>Path</code> <p>Destination directory for saving the Zarr.</p> required <code>overwrite</code> <code>bool</code> <p>If True, allows writing into a non-empty directory.</p> <code>False</code> <code>node_ids</code> <code>set[int]</code> <p>A set of nodes that should be saved. If provided, a valid graph will be constructed that also includes the ancestors of the given nodes. All other nodes will NOT be saved.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid, parent doesn't exist, is not a directory,         or if the directory is not empty and overwrite is False.</p>"},{"location":"reference/funtracks/import_export/export_to_geff/#funtracks.import_export.export_to_geff.split_position_attr","title":"split_position_attr","text":"<pre><code>split_position_attr(\n    tracks: Tracks,\n) -&gt; tuple[nx.DiGraph, list[str] | None]\n</code></pre> <p>Spread the spatial coordinates to separate node attrs in order to export to geff format.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>tracks object holding the graph to be converted.</p> required <p>Returns:</p> Type Description <code>tuple[DiGraph, list[str] | None]</code> <p>tuple[nx.DiGraph, list[str]]: graph with a separate positional attribute for each coordinate, and the axis names used to store the separate attributes</p>"},{"location":"reference/funtracks/import_export/export_utils/","title":"export_utils","text":""},{"location":"reference/funtracks/import_export/export_utils/#funtracks.import_export.export_utils","title":"funtracks.import_export.export_utils","text":""},{"location":"reference/funtracks/import_export/export_utils/#funtracks.import_export.export_utils.filter_graph_with_ancestors","title":"filter_graph_with_ancestors","text":"<pre><code>filter_graph_with_ancestors(\n    graph: DiGraph, nodes_to_keep: set[int]\n) -&gt; list[int]\n</code></pre> <p>Filter a graph to keep only the nodes in <code>nodes_to_keep</code> and their ancestors.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The original directed graph.</p> required <code>nodes_to_keep</code> <code>set[int]</code> <p>The set of nodes to keep in the graph.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A subset of the original nodes in the graph containing only the nodes in <code>nodes_to_keep</code> and their ancestors.</p>"},{"location":"reference/funtracks/import_export/import_from_geff/","title":"import_from_geff","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff","title":"funtracks.import_export.import_from_geff","text":""},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.import_from_geff","title":"import_from_geff","text":"<pre><code>import_from_geff(\n    directory: Path,\n    name_map: dict[str, str],\n    segmentation_path: Path | None = None,\n    scale: list[float] | None = None,\n    node_features: dict[str, bool] | None = None,\n    edge_prop_filter: list[str] | None = None,\n)\n</code></pre> <p>Load Tracks from a geff directory. Takes a name_map to map graph attributes (spatial dimensions and optional track and lineage ids) to tracks attributes. Optionally takes a path to segmentation data, and verifies if the segmentation data matches with the graph data. If a scaling tuple is provided, it will be used to scale the spatial coordinates on the graph (world coordinates) to pixel coordinates when checking if segmentation data matches the graph data. If no scale is provided, the geff metadata will be queried for a scale, if it is not present, no scaling will be applied. Optional extra features, present as node properties in the geff, can be included by providing a dictionary with keys as the feature names and values as booleans indicating whether to they should be recomputed (currently only supported for the 'area' feature), or loaded as static node attributes.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>path to the geff tracks data or its parent folder.</p> required <code>name_map</code> <code>dict[str, str]</code> <p>dictionary mapping required fields to node properties. Should include:     time,     (z),     y,     x,     (seg_id), if a segmentation is provided     (tracklet_id), optional, if it is a solution     (lineage_id), optional, if it is a solution</p> required <code>segmentation_path</code> <code>Path | None = None</code> <p>path to segmentation data.</p> <code>None</code> <code>scale</code> <code>list[float]</code> <p>scaling information (pixel to world coordinates).</p> <code>None</code> <code>node_features (dict[str</code> <p>bool] | None=None): optional features to include in the Tracks object. The keys are the feature names, and the boolean value indicates whether to recompute the feature (area) or load it as a static node attribute.</p> required <code>edge_prop_filter</code> <code>list[str]</code> <p>List of edge properties to include. If None all</p> <code>None</code> <p>Returns:     Tracks based on the geff graph and segmentation, if provided.</p>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.relabel_seg_id_to_node_id","title":"relabel_seg_id_to_node_id","text":"<pre><code>relabel_seg_id_to_node_id(\n    times: ArrayLike,\n    ids: ArrayLike,\n    seg_ids: ArrayLike,\n    segmentation: Array,\n) -&gt; np.ndarray\n</code></pre> <p>Create a new segmentation where masks are relabeled to match node ids.</p> <p>TODO: How does this relate to motile_toolbox.ensure_unique_labels? Just lazy/dask?</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>ArrayLike</code> <p>array of time points, one per node</p> required <code>ids</code> <code>ArrayLike</code> <p>array of node ids</p> required <code>seg_ids</code> <code>ArrayLike</code> <p>array of segmentation ids, one per node</p> required <code>segmentation</code> <code>array</code> <p>A dask array where segmentation label values match the \"seg_id\" values.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A numpy array of dtype uint64, similar to the input segmentation where each segmentation now has a unique label across time that corresponds to the ID of each node.</p>"},{"location":"reference/funtracks/import_export/import_from_geff/#funtracks.import_export.import_from_geff.validate_graph_seg_match","title":"validate_graph_seg_match","text":"<pre><code>validate_graph_seg_match(\n    in_memory_geff: InMemoryGeff,\n    segmentation: ArrayLike,\n    name_map: dict[str, str],\n    scale: list[float],\n    position_attr: list[str],\n) -&gt; bool\n</code></pre> <p>Validate if the given geff matches the provided segmentation data.</p> <p>Raises an error if no valid seg ids are provided, if the metadata axes do not match segmentation shape, or if the seg_id value of the last node does not match the pixel value at the (scaled) node coordinates. Returns a boolean indicating whether relabeling of the segmentation to match it to node id values is required.</p> <p>Parameters:</p> Name Type Description Default <code>in_memory_geff</code> <code>InMemoryGeff</code> <p>geff data read into memory</p> required <code>name_map</code> <code>dict[str, str]</code> <p>dictionary mapping required fields to node properties.</p> required <code>segmentation</code> <code>ArrayLike</code> <p>segmentation data.</p> required <code>scale</code> <code>list[float]</code> <p>scaling information (pixel to world coordinates).</p> required <code>position_attr</code> <code>list[str]</code> <p>position keys in the geff tracks data</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if relabeling from seg_id to node_id is required.</p>"},{"location":"reference/funtracks/import_export/internal_format/","title":"internal_format","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format","title":"funtracks.import_export.internal_format","text":""},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.delete_tracks","title":"delete_tracks","text":"<pre><code>delete_tracks(directory: Path | str)\n</code></pre> <p>Delete the tracks in the given directory. Also deletes the directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path | str</code> <p>Path to a directory containing tracks</p> required"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.load_tracks","title":"load_tracks","text":"<pre><code>load_tracks(\n    directory: Path,\n    seg_required: bool = False,\n    solution: bool = False,\n) -&gt; Tracks | SolutionTracks\n</code></pre> <p>Load a Tracks object from the given directory. Looks for files in the format generated by Tracks.save.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>The directory containing tracks to load</p> required <code>seg_required</code> <code>bool</code> <p>If true, raises a FileNotFoundError if the segmentation file is not present in the directory. Defaults to False.</p> <code>False</code> <code>solution</code> <code>bool</code> <p>If true, returns a SolutionTracks object, otherwise returns a normal Tracks object. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Tracks</code> <code>Tracks | SolutionTracks</code> <p>A tracks object loaded from the given directory</p>"},{"location":"reference/funtracks/import_export/internal_format/#funtracks.import_export.internal_format.save_tracks","title":"save_tracks","text":"<pre><code>save_tracks(tracks: Tracks, directory: Path) -&gt; None\n</code></pre> <p>Save the tracks to the given directory. Currently, saves the graph as a json file in networkx node link data format, saves the segmentation as a numpy npz file, and saves the time and position attributes and scale information in an attributes json file. Will make the directory if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Tracks</code> <p>the tracks to save</p> required <code>directory</code> <code>Path</code> <p>The directory to save the tracks in.</p> required"},{"location":"reference/funtracks/import_export/magic_imread/","title":"magic_imread","text":""},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread","title":"funtracks.import_export.magic_imread","text":"<p>Adapted implementation of napari.napari_builtins.io._read.magic_imread</p>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.imread","title":"imread","text":"<pre><code>imread(filename: str) -&gt; np.ndarray\n</code></pre> <p>Read an image from a string file path using tifffile.imwrite.</p>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.magic_imread","title":"magic_imread","text":"<pre><code>magic_imread(\n    filenames: PathOrStr | list[PathOrStr],\n    *,\n    use_dask=None,\n    stack=True,\n) -&gt; ArrayLike | list[ArrayLike]\n</code></pre> <p>Dispatch the appropriate reader given some files.</p>"},{"location":"reference/funtracks/import_export/magic_imread/#funtracks.import_export.magic_imread.read_zarr_dataset","title":"read_zarr_dataset","text":"<pre><code>read_zarr_dataset(\n    path: Path,\n) -&gt; tuple[ArrayLike | list[ArrayLike], tuple[int]]\n</code></pre> <p>Read a zarr dataset, including an array or a group of arrays.</p>"},{"location":"reference/funtracks/user_actions/","title":"user_actions","text":""},{"location":"reference/funtracks/user_actions/#funtracks.user_actions","title":"funtracks.user_actions","text":""},{"location":"reference/funtracks/user_actions/user_add_edge/","title":"user_add_edge","text":""},{"location":"reference/funtracks/user_actions/user_add_edge/#funtracks.user_actions.user_add_edge","title":"funtracks.user_actions.user_add_edge","text":""},{"location":"reference/funtracks/user_actions/user_add_edge/#funtracks.user_actions.user_add_edge.UserAddEdge","title":"UserAddEdge","text":"<pre><code>UserAddEdge(\n    tracks: SolutionTracks,\n    edge: tuple[int, int],\n    force: bool = False,\n)\n</code></pre> <p>               Bases: <code>ActionGroup</code></p> <p>Assumes that the endpoints already exist and have track ids.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>SolutionTracks</code> <p>the tracks to add the edge to</p> required <code>edge</code> <code>tuple[int, int]</code> <p>The edge to add</p> required <code>force</code> <code>bool</code> <p>Whether to force the action by removing any conflicting edges. Defaults to False.</p> <code>False</code>"},{"location":"reference/funtracks/user_actions/user_add_node/","title":"user_add_node","text":""},{"location":"reference/funtracks/user_actions/user_add_node/#funtracks.user_actions.user_add_node","title":"funtracks.user_actions.user_add_node","text":""},{"location":"reference/funtracks/user_actions/user_add_node/#funtracks.user_actions.user_add_node.UserAddNode","title":"UserAddNode","text":"<pre><code>UserAddNode(\n    tracks: SolutionTracks,\n    node: int,\n    attributes: dict[str, Any],\n    pixels: tuple[ndarray, ...] | None = None,\n    force: bool = False,\n)\n</code></pre> <p>               Bases: <code>ActionGroup</code></p> <p>Determines which basic actions to call when a user adds a node</p> <ul> <li>Get the track id</li> <li>Check if the track has divided earlier in time -&gt; raise InvalidActionException</li> <li>Check if there is an earlier and/or later node in the track<ul> <li>If there is earlier and later node, remove the edge between them</li> <li>Add edges between the earlier/later nodes and the new node</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>SolutionTracks</code> <p>the tracks to add the node to</p> required <code>node</code> <code>int</code> <p>The node id of the new node to add</p> required <code>attributes</code> <code>dict[str, Any]</code> <p>A dictionary from attribute strings to values. Must contain \"time\" and \"track_id\".</p> required <code>pixels</code> <code>tuple[ndarray, ...] | None</code> <p>The pixels of the associated segmentation to add to the tracks. Defaults to None.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Whether to force the action by removing any conflicting edges. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>InvalidActionError</code> <p>If the action cannot be completed because of one of</p> <code>following reasons</code> <pre><code>- attributes dictionary does not contain `time` or `track_id`.\n- a node with given ID already exists in the tracks.\n- a node is trying to be added to a track that divided in a previous\ntime point (forceable).\n- the parent track of the node will divide downstream of the current\ntime point (forceable).\n</code></pre>"},{"location":"reference/funtracks/user_actions/user_delete_edge/","title":"user_delete_edge","text":""},{"location":"reference/funtracks/user_actions/user_delete_edge/#funtracks.user_actions.user_delete_edge","title":"funtracks.user_actions.user_delete_edge","text":""},{"location":"reference/funtracks/user_actions/user_delete_node/","title":"user_delete_node","text":""},{"location":"reference/funtracks/user_actions/user_delete_node/#funtracks.user_actions.user_delete_node","title":"funtracks.user_actions.user_delete_node","text":""},{"location":"reference/funtracks/user_actions/user_update_segmentation/","title":"user_update_segmentation","text":""},{"location":"reference/funtracks/user_actions/user_update_segmentation/#funtracks.user_actions.user_update_segmentation","title":"funtracks.user_actions.user_update_segmentation","text":""},{"location":"reference/funtracks/user_actions/user_update_segmentation/#funtracks.user_actions.user_update_segmentation.UserUpdateSegmentation","title":"UserUpdateSegmentation","text":"<pre><code>UserUpdateSegmentation(\n    tracks: SolutionTracks,\n    new_value: int,\n    updated_pixels: list[tuple[tuple[ndarray, ...], int]],\n    current_track_id: int,\n    force: bool = False,\n)\n</code></pre> <p>               Bases: <code>ActionGroup</code></p> <p>Assumes that the pixels have already been updated in the project.segmentation NOTE: Re discussion with Kasia: we should have a basic action that updates the segmentation, and that is the only place the segmentation is updated. The basic add_node action doesn't have anything with pixels.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>SolutionTracks</code> <p>The solution tracks that the user is updating.</p> required <code>new_value</code> <code>int</code> <p>The new value that the user painted with</p> required <code>updated_pixels</code> <code>list[tuple[tuple[ndarray, ...], int]]</code> <p>A list of node update actions, consisting of a numpy multi-index, pointing to the array elements that were changed (a tuple with len ndims), and the value before the change</p> required <code>current_track_id</code> <code>int</code> <p>The track id to use if adding a new node, usually the currently selected track id in the viewer.</p> required <code>force</code> <code>bool</code> <p>Whether to force the operation by removing conflicting edges. Defaults to False.</p> <code>False</code>"}]}